<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">使用 <code>@defer</code> 延迟加载</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/templates/defer.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p>可延迟视图，也称为 <code>@defer</code> 控制块，通过延迟加载对于页面初始渲染并非绝对必要的代码，从而减小应用的初始捆绑包大小。这通常会加快初始加载速度并改进核心 Web 指标 (CWV)，主要是最大内容绘制 (LCP) 和首字节时间 (TTFB)。</p>
<p>要使用此特性，你可以声明式地将模板的某个部分包裹在 @defer 控制块中：</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p><code>@defer</code> 控制块内任何组件、指令和管道的代码都会被拆分到一个单独的 JavaScript 文件中，并且仅在必要时（在模板的其余部分渲染完毕后）加载。</p>
<p>可延迟视图支持各种触发器、预取选项以及用于占位符、加载和错误状态管理的子控制块。</p>

  <h2 id="which-dependencies-are-deferred">
    <a href="#which-dependencies-are-deferred" class="docs-anchor" tabindex="-1" aria-label="Link to Which dependencies are deferred?">哪些依赖项会被延迟？</a>
  </h2>
  <p>在加载应用时，组件、指令、管道以及任何组件 CSS 样式都可以被延迟。</p>
<p>为了使 <code>@defer</code> 控制块中的依赖项被延迟，它们需要满足两个条件：</p>

    <ol class="docs-ordered-list">
      <li><strong>它们必须是独立的。</strong> 非独立的依赖项无法延迟，并且仍然是急性加载的，即使它们位于 <code>@defer</code> 控制块内。</li>
<li><strong>它们不能在同一文件中 <code>@defer</code> 控制块之外被引用。</strong> 如果它们在 <code>@defer</code> 控制块之外被引用，或者在 ViewChild 查询中被引用，则这些依赖项将被急性加载。</li>

    </ol>
    <p>在 <code>@defer</code> 块中使用的组件、指令和管道的<em>传递</em>依赖项不一定需要是独立的；传递依赖项仍然可以在 <a href="/api/core/NgModule"><code>NgModule</code></a> 中声明并参与延迟加载。</p>
<p>Angular 的编译器为 <code>@defer</code> 控制块中使用的每个组件、指令和管道生成一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" target="_blank">动态导入</a> 语句。在所有导入求解后，控制块的主要内容才会渲染。Angular 不保证这些导入的任何特定顺序。</p>

  <h2 id="how-to-manage-different-stages-of-deferred-loading">
    <a href="#how-to-manage-different-stages-of-deferred-loading" class="docs-anchor" tabindex="-1" aria-label="Link to How to manage different stages of deferred loading">如何管理延迟加载的不同阶段</a>
  </h2>
  <p><code>@defer</code> 控制块有几个子控制块，可让你优雅地处理延迟加载过程中的不同阶段。</p>

  <h3 id="defer">
    <a href="#defer" class="docs-anchor" tabindex="-1" aria-label="Link to <code>@defer</code>"><code>@defer</code></a>
  </h3>
  <p>这是定义惰性加载内容部分的主要块。它最初不会渲染——一旦指定的 <a href="/guide/templates/defer#triggers">触发器</a> 发生或满足 <code>when</code> 条件，延迟内容就会加载并渲染。</p>
<p>默认情况下，当浏览器状态变为 <a href="/guide/templates/defer#idle">空闲</a> 时，@defer 块会被触发。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h3 id="show-placeholder-content-with-placeholder">
    <a href="#show-placeholder-content-with-placeholder" class="docs-anchor" tabindex="-1" aria-label="Link to Show placeholder content with <code>@placeholder</code>">使用 <code>@placeholder</code> 显示占位符内容</a>
  </h3>
  <p>默认情况下，defer 控制块在被触发之前不渲染任何内容。</p>
<p><code>@placeholder</code> 是一个可选的控制块，用于声明在 <code>@defer</code> 控制块被触发之前要显示的内容。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Placeholder content&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>虽然是可选的，但某些触发器可能需要 <code>@placeholder</code> 或 <a href="/guide/templates/variables#template-reference-variables">模板引用变量</a> 的存在才能工作。有关更多详细信息，请参阅 <a href="/guide/templates/defer#triggers">触发器</a> 部分。</p>
<p>加载完成后，Angular 会将占位符内容替换为主内容。你可以在占位符部分使用任何内容，包括纯 HTML、组件、指令和管道。请记住，<em>占位符控制块的依赖项是急性加载的</em>。</p>
<p><code>@placeholder</code> 控制块接受一个可选参数，用于指定在占位符内容初始渲染后，此占位符应显示的<code>minimum</code> 最短时间。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (minimum 500ms) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Placeholder content&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>此 <code>minimum</code> 参数以毫秒 (ms) 或秒 (s) 的时间增量指定。你可以使用此参数来防止在快速获取延迟依赖项的情况下占位符内容快速闪烁。</p>

  <h3 id="show-loading-content-with-loading">
    <a href="#show-loading-content-with-loading" class="docs-anchor" tabindex="-1" aria-label="Link to Show loading content with <code>@loading</code>">使用 <code>@loading</code> 显示加载内容</a>
  </h3>
  <p><code>@loading</code> 控制块是一个可选的控制块，允许你声明在延迟依赖项加载时显示的内容。一旦触发加载，它将替换 <code>@placeholder</code> 控制块。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> alt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"loading..."</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"loading.gif"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Placeholder content&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>它的依赖项是急性加载的（类似于 <code>@placeholder</code>）。</p>
<p><code>@loading</code> 控制块接受两个可选参数，以帮助防止在快速获取延迟依赖项时可能发生的内容快速闪烁，：</p>

  <ul class="docs-list">
    <li><code>minimum</code> - 此占位符应显示的最短时间</li>
<li><code>after</code> - 加载开始后，在显示加载模板之前要等待的时间量</li>

  </ul>
  <div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (after 100ms; minimum 1s) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> alt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"loading..."</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"loading.gif"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>这两个参数都以毫秒 (ms) 或秒 (s) 的时间增量指定。此外，这两个参数的计时器都在加载被触发后立即开始。</p>

  <h3 id="show-error-state-when-deferred-loading-fails-with-error">
    <a href="#show-error-state-when-deferred-loading-fails-with-error" class="docs-anchor" tabindex="-1" aria-label="Link to Show error state when deferred loading fails with <code>@error</code>">当延迟加载失败时，使用 <code>@error</code> 显示错误状态</a>
  </h3>
  <p><code>@error</code> 控制块是一个可选的控制块，用于在延迟加载失败时显示。与 <code>@placeholder</code> 和 <code>@loading</code> 类似，@error 控制块的依赖项是急性加载的。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Failed to load large component.&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h2 id="controlling-deferred-content-loading-with-triggers">
    <a href="#controlling-deferred-content-loading-with-triggers" class="docs-anchor" tabindex="-1" aria-label="Link to Controlling deferred content loading with triggers">使用触发器控制延迟内容加载</a>
  </h2>
  <p>你可以指定<strong>触发器</strong>来控制 Angular 何时加载和显示延迟内容。</p>
<p>当 <code>@defer</code> 控制块被触发时，它会将占位符内容替换为惰性加载的内容。</p>
<p>可以通过用分号 <code>;</code> 分隔来定义多个事件触发器，并将它们评估为 OR 条件。</p>
<p>触发器有两种类型：<code>on</code> 和 <code>when</code>。</p>

  <h3 id="on">
    <a href="#on" class="docs-anchor" tabindex="-1" aria-label="Link to <code>on</code>"><code>on</code></a>
  </h3>
  <p><code>on</code> 指定触发 <code>@defer</code> 控制块的条件。</p>
<p>可用的触发器如下：</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th>触发器</th>
<th>描述</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td><a href="#idle"><code>idle</code></a></td>
<td>当浏览器空闲时触发。</td>
</tr>
<tr>
<td><a href="#viewport"><code>viewport</code></a></td>
<td>当指定内容进入视口时触发</td>
</tr>
<tr>
<td><a href="#interaction"><code>interaction</code></a></td>
<td>当用户与指定元素交互时触发</td>
</tr>
<tr>
<td><a href="#hover"><code>hover</code></a></td>
<td>当鼠标悬停在指定区域上方时触发</td>
</tr>
<tr>
<td><a href="#immediate"><code>immediate</code></a></td>
<td>在非延迟内容完成渲染后立即触发</td>
</tr>
<tr>
<td><a href="#timer"><code>timer</code></a></td>
<td>在特定持续时间后触发</td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h4 id="idle">
    <a href="#idle" class="docs-anchor" tabindex="-1" aria-label="Link to <code>idle</code>"><code>idle</code></a>
  </h4>
  <p><code>idle</code> 触发器在浏览器基于 requestIdleCallback 达到空闲状态后加载延迟内容。这是 defer 控制块的默认行为。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">&lt;!-- @defer (on idle) --&gt;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h4 id="viewport">
    <a href="#viewport" class="docs-anchor" tabindex="-1" aria-label="Link to <code>viewport</code>"><code>viewport</code></a>
  </h4>
  <p>当指定内容使用 <a href="https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API" target="_blank">Intersection Observer API</a> 进入视口时，<code>viewport</code> 触发器会加载延迟内容。观察到的内容可以是 <code>@placeholder</code> 内容或显式元素引用。</p>
<p>默认情况下，<code>@defer</code> 监视占位符是否进入视口。以这种方式使用的占位符必须具有单个根元素。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on viewport) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>或者，你可以在与 <code>@defer</code> 块相同的模板中指定一个 <a href="/guide/templates/variables">模板引用变量</a>，作为被监视以进入视口的元素。此变量作为视口触发器上的参数传入。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> #greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Hello!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">viewport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(greeting)) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">greetings-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h4 id="interaction">
    <a href="#interaction" class="docs-anchor" tabindex="-1" aria-label="Link to <code>interaction</code>"><code>interaction</code></a>
  </h4>
  <p>当用户通过 <code>click</code> 或 <code>keydown</code> 事件与指定元素交互时，<code>interaction</code> 触发器会加载延迟加载内容。</p>
<p>默认情况下，占位符充当交互元素。以这种方式使用的占位符必须具有单个根元素。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on interaction) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>或者，您可以在 <code>@defer</code> 块的同一模板中指定一个 <a href="/guide/templates/variables">模板引用变量</a>，作为观察交互的元素。此变量将作为参数传递给视口触发器。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> #greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Hello!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">interaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(greeting)) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">greetings-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h4 id="hover">
    <a href="#hover" class="docs-anchor" tabindex="-1" aria-label="Link to <code>hover</code>"><code>hover</code></a>
  </h4>
  <p>当鼠标通过 <code>mouseover</code> 和 <code>focusin</code> 事件悬停在触发区域上方时，<code>hover</code> 触发器会加载延迟加载内容。</p>
<p>默认情况下，占位符充当交互元素。以这种方式使用的占位符必须具有单个根元素。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on hover) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>或者，你可以在与 <code>@defer</code> 块相同的模板中指定一个 <a href="/guide/templates/variables">模板引用变量</a>，作为被监视以进入视口的元素。此变量作为视口触发器上的参数传入。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> #greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Hello!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">hover</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(greeting)) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">greetings-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h4 id="immediate">
    <a href="#immediate" class="docs-anchor" tabindex="-1" aria-label="Link to <code>immediate</code>"><code>immediate</code></a>
  </h4>
  <p><code>immediate</code> 触发器会立即加载延迟加载内容。这意味着延迟加载块会在所有其他非延迟加载内容完成渲染后立即加载。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on immediate) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h4 id="timer">
    <a href="#timer" class="docs-anchor" tabindex="-1" aria-label="Link to <code>timer</code>"><code>timer</code></a>
  </h4>
  <p><code>timer</code> 触发器会在指定的时长后加载延迟加载内容。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">timer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(500ms)) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>时长参数必须以毫秒 (<code>ms</code>) 或秒 (<code>s</code>) 为单位指定。</p>

  <h3 id="when">
    <a href="#when" class="docs-anchor" tabindex="-1" aria-label="Link to <code>when</code>"><code>when</code></a>
  </h3>
  <p><code>when</code> 触发器接受自定义条件表达式，并在条件变为真值时加载延迟加载内容。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (when condition) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>这是一次性操作——如果条件在变为真值后又变为假值，<code>@defer</code> 块不会恢复为占位符。</p>

  <h2 id="prefetching-data-with-prefetch">
    <a href="#prefetching-data-with-prefetch" class="docs-anchor" tabindex="-1" aria-label="Link to Prefetching data with <code>prefetch</code>">使用 <code>prefetch</code> 预取数据</a>
  </h2>
  <p>除了指定确定何时显示延迟加载内容的条件之外，你还可以选择性地指定一个 <strong>预取触发器</strong>。此触发器允许你在显示延迟加载内容之前加载与 <code>@defer</code> 块关联的 JavaScript。</p>
<p>预取启用更高级的行为，例如允许你在用户实际看到或与 defer 块交互之前开始预取资源，但用户可能很快会与之交互，从而更快地提供资源。</p>
<p>你可以指定一个预取触发器，方式与块的主要触发器类似，但要以 <code>prefetch</code> 关键字为前缀。块的主要触发器和预取触发器用分号字符 (<code>;</code>) 分隔。</p>
<p>在下面的示例中，预取在浏览器空闲时开始，并且仅在用户与占位符交互后才渲染块的内容。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (on interaction; prefetch on idle) {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-cmp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;Large component placeholder&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h2 id="testing-defer-blocks">
    <a href="#testing-defer-blocks" class="docs-anchor" tabindex="-1" aria-label="Link to Testing <code>@defer</code> blocks">测试 <code>@defer</code> 块</a>
  </h2>
  <p>Angular 提供了 TestBed API，以简化测试 <code>@defer</code> 块和在测试期间触发不同状态的过程。默认情况下，测试中的 <code>@defer</code> 块的运行方式与真实应用中的 defer 块的行为方式相同。如果想手动单步执行状态，可以在 TestBed 配置中将 defer 块行为切换为 <code>Manual</code>。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">it</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'should render a defer block in different states'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // configures the defer block behavior to start in "paused" state for manual control.</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  <a href="/api/core/testing/TestBed">TestBed</a>.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">configureTestingModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({deferBlockBehavior: DeferBlockBehavior.Manual});</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/Component">Component</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // ...</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">`</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">      @defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">large-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> /&gt;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@placeholder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        Placeholder</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">@loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        Loading...</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      }</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    `</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  })</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> ComponentA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {}</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // Create component fixture.</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> componentFixture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> <a href="/api/core/testing/TestBed">TestBed</a>.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/createComponent">createComponent</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(ComponentA);</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // Retrieve the list of all defer block fixtures and get the first block.</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> deferBlockFixture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> componentFixture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">getDeferBlocks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">())[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">];</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // Renders placeholder state by default.</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  expect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(componentFixture.nativeElement.innerHTML).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">toContain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'Placeholder'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // Render loading state and verify rendered output.</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> deferBlockFixture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(<a href="/api/core/testing/DeferBlockState">DeferBlockState</a>.Loading);</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  expect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(componentFixture.nativeElement.innerHTML).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">toContain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'Loading'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // Render final state and verify the output.</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> deferBlockFixture.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(<a href="/api/core/testing/DeferBlockState">DeferBlockState</a>.Complete);</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  expect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(componentFixture.nativeElement.innerHTML).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">toContain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'large works!'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">});</span></span></code></pre>
  </div>
  <h2 id="does-defer-work-with-ngmodule">
    <a href="#does-defer-work-with-ngmodule" class="docs-anchor" tabindex="-1" aria-label="Link to Does <code>@defer</code> work with <code>NgModule</code>?"><code>@defer</code> 可以与 <code>NgModule</code> 一起使用吗？</a>
  </h2>
  <p><code>@defer</code> 控制块与独立组件和基于 NgModule 的组件、指令和管道都兼容。但是，<strong>只有独立的组件、指令和管道可以被延迟</strong>。基于 NgModule 的依赖项不会被延迟，并且包含在急性加载的捆绑包中。</p>

  <h2 id="how-does-defer-work-with-server-side-rendering-ssr-and-static-site-generation-ssg">
    <a href="#how-does-defer-work-with-server-side-rendering-ssr-and-static-site-generation-ssg" class="docs-anchor" tabindex="-1" aria-label="Link to How does <code>@defer</code> work with server-side rendering (SSR) and static-site generation (SSG)?"><code>@defer</code> 如何与服务器端渲染 (SSR) 和静态站点生成 (SSG) 一起工作？</a>
  </h2>
  <p>默认情况下，当在服务器上渲染应用（无论是使用 SSR 还是 SSG）时，defer 块始终渲染它们的 <code>@placeholder</code>（如果未指定占位符，则不渲染任何内容），并且触发器不会被调用。在客户端，<code>@placeholder</code> 的内容会被水合，并且触发器会被激活。</p>
<p>要在服务器上（SSR 和 SSG）渲染 <code>@defer</code> 块的主要内容，你可以启用 <a href="/guide/incremental-hydration">水合增强特性</a> 并为必要的块配置 <code>hydrate</code> 触发器。</p>

  <h2 id="best-practices-for-deferring-views">
    <a href="#best-practices-for-deferring-views" class="docs-anchor" tabindex="-1" aria-label="Link to Best practices for deferring views">延迟加载视图的最佳实践</a>
  </h2>
  
  <h3 id="avoid-cascading-loads-with-nested-defer-blocks">
    <a href="#avoid-cascading-loads-with-nested-defer-blocks" class="docs-anchor" tabindex="-1" aria-label="Link to Avoid cascading loads with nested <code>@defer</code> blocks">避免使用嵌套的 <code>@defer</code> 块进行级联加载</a>
  </h3>
  <p>当你有嵌套的 <code>@defer</code> 块时，它们应该具有不同的触发器，以避免同时加载，这会导致级联请求并可能对页面加载性能产生负面影响。</p>

  <h3 id="avoid-layout-shifts">
    <a href="#avoid-layout-shifts" class="docs-anchor" tabindex="-1" aria-label="Link to Avoid layout shifts">避免布局偏移</a>
  </h3>
  <p>避免延迟加载在初始加载时在用户视口中可见的组件。这样做可能会通过导致累积布局偏移 (CLS) 增加而对 Core Web Vitals 产生负面影响。</p>
<p>如果这种情况是必要的，请避免使用 <code>immediate</code>、<code>timer</code>、<code>viewport</code> 和自定义 <code>when</code> 触发器，这些触发器会导致内容在初始页面渲染期间加载。</p>
