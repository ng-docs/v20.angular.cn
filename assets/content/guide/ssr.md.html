<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">服务器端渲染和混合渲染</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/guide/ssr.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p>Angular 默认将所有应用作为客户端渲染 (CSR) 应用发布。虽然这种方法提供的初始负载很轻，但它也带来了权衡，包括加载时间变慢、性能指标下降以及更高的资源需求，因为用户设备执行了大部分计算。因此，许多应用通过将服务器端渲染 (SSR) 集成到混合渲染策略中，实现了显著的性能改进。</p>

  <h2 id="what-is-hybrid-rendering">
    <a href="#what-is-hybrid-rendering" class="docs-anchor" tabindex="-1" aria-label="Link to What is hybrid rendering?">什么是混合渲染？</a>
  </h2>
  <p>混合渲染允许开发人员利用服务器端渲染 (SSR)、预渲染（也称为“静态站点生成”或 SSG）和客户端渲染 (CSR) 的优势来优化您的 Angular 应用。它让您可以精细地控制应用的不同部分的渲染方式，从而为用户提供最佳体验。</p>

  <h2 id="setting-up-hybrid-rendering">
    <a href="#setting-up-hybrid-rendering" class="docs-anchor" tabindex="-1" aria-label="Link to Setting up hybrid rendering">设置混合渲染</a>
  </h2>
  <p>您可以使用 Angular CLI 的 <code>ng new</code> 命令配合服务器端渲染标志（即 <code>--ssr</code>）来创建一个支持混合渲染的<strong>新</strong>项目：</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --ssr</span></span></code></pre>
  </div><p>您也可以使用 <code>ng add</code> 命令将服务器端渲染添加到现有项目中，以启用混合渲染：</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> @angular/ssr</span></span></code></pre>
  </div>
    <div class="docs-alert docs-alert-note">
    <p><strong>注意：</strong>默认情况下，Angular 会预渲染您的整个应用程序并生成一个服务器文件。要禁用此功能并创建完全静态的应用，请将 <code>outputMode</code> 设置为 <code>static</code>。要启用 SSR，请将服务器路由更新为使用 <a href="/api/ssr/RenderMode#Server"><code>RenderMode.Server</code></a>。有关更多详细信息，请参阅 <a href="#server-routing"><code>服务器路由</code></a> 和 <a href="#generate-a-fully-static-application"><code>生成完全静态的应用</code></a>。</p>

    </div>
    
  <h2 id="server-routing">
    <a href="#server-routing" class="docs-anchor" tabindex="-1" aria-label="Link to Server routing">服务器路由</a>
  </h2>
  
  <h3 id="configuring-server-routes">
    <a href="#configuring-server-routes" class="docs-anchor" tabindex="-1" aria-label="Link to Configuring server routes">配置服务器路由</a>
  </h3>
  <p>您可以通过声明一个 <a href="api/ssr/ServerRoute" title="API reference"></a><a href="/api/ssr/ServerRoute"><code>ServerRoute</code></a> 对象数组来创建服务器路由配置。此配置通常位于名为 <code>app.routes.server.ts</code> 的文件中。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// app.routes.server.ts</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/ssr/RenderMode">RenderMode</a>, ServerRoute } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> serverRoutes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/ServerRoute">ServerRoute</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">''</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// This renders the "/" route on the client (CSR)</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Client,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'about'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// This page is static, so we prerender it (SSG)</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Prerender,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'profile'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// This page requires user-specific data, so we use SSR</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Server,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'**'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// All other routes will be rendered on the server (SSR)</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Server,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">];</span></span></code></pre>
  </div><p>您可以使用 <a href="api/ssr/provideServerRendering" title="API reference"><code>provideServerRendering</code></a> 和 <a href="api/ssr/withRoutes" title="API reference"></a><a href="/api/ssr/withRoutes"><code>withRoutes</code></a> 函数将此配置添加到您的应用程序中：</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { provideServerRendering, withRoutes } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { serverRoutes } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> './app.routes.server'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// app.config.server.ts</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> serverConfig</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> ApplicationConfig</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  providers: [</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    provideServerRendering</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/ssr/withRoutes">withRoutes</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(serverRoutes)),</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // ... other providers ...</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  ]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">};</span></span></code></pre>
  </div><p>在使用 <a href="ecosystem/service-workers/app-shell">应用外壳模式</a>时，您必须为客户端渲染的路由指定用作应用外壳的组件。为此，请使用 <a href="api/ssr/withAppShell" title="API reference"></a><a href="/api/ssr/withAppShell"><code>withAppShell</code></a> 功能：</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { provideServerRendering, withRoutes, withAppShell } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { AppShellComponent } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> './app-shell/app-shell.component'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> serverConfig</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> ApplicationConfig</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  providers: [</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    provideServerRendering</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">      <a href="/api/ssr/withRoutes">withRoutes</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(serverRoutes),</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">      <a href="/api/ssr/withAppShell">withAppShell</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(AppShellComponent),</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    ),</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // ... other providers ...</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  ]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">};</span></span></code></pre>
  </div>
  <h3 id="rendering-modes">
    <a href="#rendering-modes" class="docs-anchor" tabindex="-1" aria-label="Link to Rendering modes">渲染模式</a>
  </h3>
  <p>服务器路由配置允许您通过设置 <a href="api/ssr/RenderMode" title="API reference"></a><a href="/api/ssr/RenderMode"><code>RenderMode</code></a> 来指定应用程序中每个路由的渲染方式：</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th>渲染模式</th>
<th>描述</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td><strong>服务器端 (SSR)</strong></td>
<td>为每个请求在服务器上渲染应用程序，将一个完全填充的 HTML 页面发送到浏览器。</td>
</tr>
<tr>
<td><strong>客户端 (CSR)</strong></td>
<td>在浏览器中渲染应用程序。这是 Angular 的默认行为。</td>
</tr>
<tr>
<td><strong>预渲染 (SSG)</strong></td>
<td>在构建时预渲染应用程序，为每个路由生成静态 HTML 文件。</td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h4 id="choosing-a-rendering-mode">
    <a href="#choosing-a-rendering-mode" class="docs-anchor" tabindex="-1" aria-label="Link to Choosing a rendering mode">选择渲染模式</a>
  </h4>
  <p>每种渲染模式都有不同的优点和缺点。您可以根据应用的具体需求选择渲染模式。</p>

  <h5 id="client-side-rendering-csr">
    <a href="#client-side-rendering-csr" class="docs-anchor" tabindex="-1" aria-label="Link to Client-side rendering (CSR)">客户端渲染 (CSR)</a>
  </h5>
  <p>客户端渲染具有最简单的开发模式，因为您可以编写假定代码始终在 Web 浏览器中运行的代码。这使您可以使用广泛的客户端库，这些库也假定它们在浏览器中运行。</p>
<p>客户端渲染的性能通常比其他渲染模式差，因为它必须在用户看到任何渲染内容之前下载、解析和执行您页面的 JavaScript。如果您的页面在渲染时从服务器获取更多数据，用户还必须等待这些额外的请求才能查看完整内容。</p>
<p>如果您的页面被搜索引擎爬虫索引，客户端渲染可能会对搜索引擎优化 (SEO) 产生负面影响，因为搜索引擎爬虫在索引页面时对其执行的 JavaScript 量有限制。</p>
<p>在进行客户端渲染时，服务器除了提供静态 JavaScript 资源外，无需执行任何渲染工作。如果服务器成本是一个考虑因素，您可以考虑此因素。</p>
<p>支持通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank">service workers</a> 实现可安装的离线体验的应用，可以在无需与服务器通信的情况下依赖客户端渲染。</p>

  <h5 id="server-side-rendering-ssr">
    <a href="#server-side-rendering-ssr" class="docs-anchor" tabindex="-1" aria-label="Link to Server-side rendering (SSR)">服务器端渲染 (SSR)</a>
  </h5>
  <p>服务器端渲染比客户端渲染提供更快的页面加载速度。服务器在收到浏览器请求后，无需等待 JavaScript 下载和运行，而是直接渲染 HTML 文档。用户只会体验到服务器获取数据和渲染请求页面所需的延迟。此模式还消除了浏览器进行额外网络请求的需要，因为您的代码可以在服务器渲染期间获取数据。</p>
<p>服务器端渲染通常具有出色的搜索引擎优化 (SEO)，因为搜索引擎爬虫会收到一个完全渲染的 HTML 文档。</p>
<p>服务器端渲染要求您编写不严格依赖浏览器 API 的代码，并限制您选择假定在浏览器中运行的 JavaScript 库。</p>
<p>在进行服务器端渲染时，您的服务器会运行 Angular 为每个请求生成 HTML 响应，这可能会增加服务器托管成本。</p>

  <h5 id="build-time-prerendering">
    <a href="#build-time-prerendering" class="docs-anchor" tabindex="-1" aria-label="Link to Build-time prerendering">构建时预渲染</a>
  </h5>
  <p>预渲染比客户端渲染和服务器端渲染都提供更快的页面加载速度。由于预渲染在<em>构建时</em>创建 HTML 文档，服务器可以直接以静态 HTML 文档响应请求，无需任何额外工作。</p>
<p>预渲染要求在<em>构建时</em>即可获得渲染页面所需的所有信息。这意味着预渲染的页面不能包含特定于加载页面的用户的数据。预渲染主要适用于对应用的所有用户都相同的页面。</p>
<p>由于预渲染在构建时发生，它可能会为您的生产构建增加显著的时间。使用 <a href="api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams" title="API reference"><code>getPrerenderParams</code></a> 生成大量 HTML 文档可能会影响您部署的总文件大小，从而导致部署变慢。</p>
<p>预渲染通常具有出色的搜索引擎优化 (SEO)，因为搜索引擎爬虫会收到一个完全渲染的 HTML 文档。</p>
<p>预渲染要求您编写不严格依赖浏览器 API 的代码，并限制您选择假定在浏览器中运行的 JavaScript 库。</p>
<p>预渲染在每次服务器请求时产生的开销极小，因为您的服务器会响应静态 HTML 文档。静态文件还可以轻松地被内容分发网络 (CDN)、浏览器和中间缓存层缓存，以实现更快的后续页面加载。完全静态的网站还可以仅通过 CDN 或静态文件服务器进行部署，从而无需为您的应用维护自定义服务器运行时。这通过将工作从应用 Web 服务器卸载来增强可扩展性，使其对高流量应用特别有利。</p>

    <div class="docs-alert docs-alert-note">
    <p><strong>注意：</strong>使用 Angular service worker 时，第一个请求是服务器端渲染的，但所有后续请求都由 service worker 处理并进行客户端渲染。</p>

    </div>
    
  <h3 id="setting-headers-and-status-codes">
    <a href="#setting-headers-and-status-codes" class="docs-anchor" tabindex="-1" aria-label="Link to Setting headers and status codes">设置标头和状态码</a>
  </h3>
  <p>您可以使用 <a href="/api/ssr/ServerRoute"><code>ServerRoute</code></a> 配置中的 <code>headers</code> 和 <code>status</code> 属性为单个服务器路由设置自定义标头和状态码。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// app.routes.server.ts</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/ssr/RenderMode">RenderMode</a>, ServerRoute } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> serverRoutes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/ServerRoute">ServerRoute</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'profile'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Server,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    headers: {</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      'X-My-Custom-Header'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'some-value'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    status: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">201</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // ... other routes</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">];</span></span></code></pre>
  </div>
  <h3 id="redirects">
    <a href="#redirects" class="docs-anchor" tabindex="-1" aria-label="Link to Redirects">重定向</a>
  </h3>
  <p>Angular 在服务器端以不同的方式处理路由配置中由 <a href="api/router/Route#redirectTo" title="API reference"><code>redirectTo</code></a> 属性指定的重定向。</p>
<p><strong>服务器端渲染 (SSR)</strong>
重定向在服务器端渲染过程中使用标准的 HTTP 重定向（例如 301、302）执行。</p>
<p><strong>预渲染 (SSG)</strong>
重定向通过预渲染的 HTML 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#refresh" target="_blank"><code>&lt;meta http-equiv="refresh"&gt;</code></a> 标签实现为“软重定向”。</p>

  <h3 id="customizing-build-time-prerendering-ssg">
    <a href="#customizing-build-time-prerendering-ssg" class="docs-anchor" tabindex="-1" aria-label="Link to Customizing build-time prerendering (SSG)">自定义构建时预渲染 (SSG)</a>
  </h3>
  <p>使用 <a href="api/ssr/RenderMode#Prerender" title="API reference"></a><a href="/api/ssr/RenderMode#Prerender"><code>RenderMode.Prerender</code></a> 时，您可以指定多个配置选项来定制预渲染和提供过程。</p>

  <h4 id="parameterized-routes">
    <a href="#parameterized-routes" class="docs-anchor" tabindex="-1" aria-label="Link to Parameterized routes">参数化路由</a>
  </h4>
  <p>对于每个使用 <a href="api/ssr/RenderMode#Prerender" title="API reference"></a><a href="/api/ssr/RenderMode#Prerender"><code>RenderMode.Prerender</code></a> 的路由，您可以指定一个 <a href="api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams" title="API reference"><code>getPrerenderParams</code></a> 函数。此函数允许您控制哪些特定参数会生成单独的预渲染文档。</p>
<p><code>getPrerenderParams</code> 函数返回一个 <code>Promise</code>，该 Promise 解析为一个对象数组。每个对象都是一个路由参数名到值的键值映射。例如，如果您定义了一个像 <code>post/:id</code> 这样的路由，<code>getPrerenderParams</code> 可以返回数组 <code>[{id: 123}, {id: 456}]</code>，从而为 <code>post/123</code> 和 <code>post/456</code> 渲染单独的文档。</p>
<p><a href="api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams" title="API reference"><code>getPrerenderParams</code></a> 的主体可以使用 Angular 的 <a href="api/core/inject" title="API reference"><code>inject</code></a> 函数来注入依赖项并执行任何工作以确定要预渲染的路由。这通常包括发出请求以获取数据来构建参数值数组。</p>
<p>您还可以将此函数与通配符路由（例如 <code>/**</code>）一起使用，其中参数名将是 <code>"**"</code>，返回值将是路径的片段，例如 <code>foo/bar</code>。这些可以与其他参数（例如 <code>/post/:id/**</code>）结合使用以处理更复杂的路由配置。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// app.routes.server.ts</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/ssr/RenderMode">RenderMode</a>, ServerRoute } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> serverRoutes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/ServerRoute">ServerRoute</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'post/:id'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Prerender,</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> getPrerenderParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> dataService</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(PostService);</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> ids</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> dataService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">getIds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// Assuming this returns ['1', '2', '3']</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> ids.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> ({ id })); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// Generates paths like: /post/1, /post/2, /post/3</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'post/:id/**'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Prerender,</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> getPrerenderParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'1'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'**'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'foo/3'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'2'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'**'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'bar/4'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      ]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// Generates paths like: /post/1/foo/3, /post/2/bar/4</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">];</span></span></code></pre>
  </div><p>由于 <a href="api/ssr/ServerRoutePrerenderWithParams#getPrerenderParams" title="API reference"><code>getPrerenderParams</code></a> 仅适用于 <a href="api/ssr/RenderMode#Prerender" title="API reference"></a><a href="/api/ssr/RenderMode#Prerender"><code>RenderMode.Prerender</code></a>，因此此函数始终在<em>构建时</em>运行。<code>getPrerenderParams</code> 不能依赖任何特定于浏览器或特定于服务器的 API 来获取数据。</p>

    <div class="docs-alert docs-alert-important">
    <p><strong>重要提示：</strong>在 <code>getPrerenderParams</code> 中使用 <a href="api/core/inject" title="API reference"><code>inject</code></a> 时，请记住 <code>inject</code> 必须同步使用。它不能在异步回调或任何 <code>await</code> 语句之后调用。有关更多信息，请参阅 <a href="api/core/runInInjectionContext"></a><a href="/api/core/runInInjectionContext"><code>runInInjectionContext</code></a>。</p>

    </div>
    
  <h4 id="fallback-strategies">
    <a href="#fallback-strategies" class="docs-anchor" tabindex="-1" aria-label="Link to Fallback strategies">回退策略</a>
  </h4>
  <p>使用 <a href="api/ssr/RenderMode#Prerender" title="API reference"></a><a href="/api/ssr/RenderMode#Prerender"><code>RenderMode.Prerender</code></a> 模式时，您可以指定一个回退策略来处理尚未预渲染的路径的请求。</p>
<p>可用的回退策略有：</p>

  <ul class="docs-list">
    <li><strong>Server：</strong>回退到服务器端渲染。如果未指定 <code>fallback</code> 属性，这是<strong>默认</strong>行为。</li>
<li><strong>Client：</strong>回退到客户端渲染。</li>
<li><strong>None：</strong>无回退。Angular 将不会处理未预渲染的路径的请求。</li>

  </ul>
  <div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// app.routes.server.ts</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/ssr/RenderMode">RenderMode</a>, PrerenderFallback, ServerRoute } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> serverRoutes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/ServerRoute">ServerRoute</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'post/:id'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    renderMode: RenderMode.Prerender,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    fallback: PrerenderFallback.Client, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// Fallback to CSR if not prerendered</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> getPrerenderParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() {</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">      // This function returns an array of objects representing prerendered posts at the paths:</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">      // `/post/1`, `/post/2`, and `/post/3`.</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">      // The path `/post/4` will utilize the fallback behavior if it's requested.</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [{ id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> }, { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> }, { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> }];</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">];</span></span></code></pre>
  </div>
  <h2 id="authoring-server-compatible-components">
    <a href="#authoring-server-compatible-components" class="docs-anchor" tabindex="-1" aria-label="Link to Authoring server-compatible components">编写服务器兼容的组件</a>
  </h2>
  <p>某些常见的浏览器 API 和功能可能在服务器上不可用。应用无法使用特定于浏览器的全局对象，如 <code>window</code>、<code>document</code>、<code>navigator</code> 或 <code>location</code>，以及 <code>HTMLElement</code> 的某些属性。</p>
<p>通常，依赖于特定于浏览器的符号的代码应仅在浏览器中执行，而不是在服务器上执行。这可以通过 <a href="api/core/afterEveryRender"></a><a href="/api/core/afterEveryRender"><code>afterEveryRender</code></a> 和 <a href="api/core/afterNextRender"></a><a href="/api/core/afterNextRender"><code>afterNextRender</code></a> 生命周期钩子来强制执行。这些钩子仅在浏览器中执行，在服务器上会被跳过。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/core/Component">Component</a>, ViewChild, afterNextRender } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/Component">Component</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'my-cmp'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">span</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> #content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;{{ ... }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/ViewChild">ViewChild</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'content'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">contentRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/core/ElementRef">ElementRef</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() {</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    <a href="/api/core/afterNextRender">afterNextRender</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">      // Safe to check `scrollHeight` because this will only run in the browser, not the server.</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'content height: '</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.contentRef.nativeElement.scrollHeight);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    });</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h2 id="accessing-request-and-response-via-di">
    <a href="#accessing-request-and-response-via-di" class="docs-anchor" tabindex="-1" aria-label="Link to Accessing Request and Response via DI">通过 DI 访问请求和响应</a>
  </h2>
  <p><code>@angular/core</code> 包提供了几个用于与服务器端渲染环境交互的令牌。这些令牌使您在 SSR 期间能够访问 Angular 应用中的关键信息和对象。</p>

  <ul class="docs-list">
    <li><strong><a href="api/core/REQUEST" title="API reference"></a><a href="/api/core/REQUEST"><code>REQUEST</code></a>：</strong>提供对当前请求对象的访问，该对象是 Web API 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank"><code>Request</code></a> 类型。这使您可以访问标头、cookie 和其他请求信息。</li>
<li><strong><a href="api/core/RESPONSE_INIT" title="API reference"></a><a href="/api/core/RESPONSE_INIT"><code>RESPONSE_INIT</code></a>：</strong>提供对响应初始化选项的访问，该选项是 Web API 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#parameters" target="_blank"><code>ResponseInit</code></a> 类型。这使您可以动态设置响应的标头和状态码。使用此令牌设置需要在运行时确定的标头或状态码。</li>
<li><strong><a href="api/core/REQUEST_CONTEXT" title="API reference"></a><a href="/api/core/REQUEST_CONTEXT"><code>REQUEST_CONTEXT</code></a>:</strong> 提供对与当前请求相关的附加上下文的访问。此上下文可以作为 <a href="api/ssr/AngularAppEngine#handle" title="API reference"><code>handle</code></a> 函数的第二个参数传递。通常，这用于提供不属于标准 Web API 的与请求相关的附加信息。</li>

  </ul>
  <div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { inject, REQUEST } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/Component">Component</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  selector: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'app-my-component'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;My Component&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">() {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> request</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"><a href="/api/core/REQUEST">REQUEST</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(request?.url);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
    <div class="docs-alert docs-alert-important">
    <p><strong>重要提示：</strong> 在以下场景中，上述令牌将为 <code>null</code>：</p>

    </div>
    
  <ul class="docs-list">
    <li>在构建过程中。</li>
<li>当应用程序在浏览器中渲染时（CSR）。</li>
<li>执行静态站点生成（SSG）时。</li>
<li>在开发过程中提取路由时（在请求时）。</li>

  </ul>
  
  <h2 id="generate-a-fully-static-application">
    <a href="#generate-a-fully-static-application" class="docs-anchor" tabindex="-1" aria-label="Link to Generate a fully static application">生成完全静态的应用程序</a>
  </h2>
  <p>默认情况下，Angular 会预渲染您的整个应用程序并生成一个用于处理请求的服务器文件。这允许您的应用程序向用户提供预渲染的内容。但是，如果您希望拥有一个完全静态的站点而无需服务器，可以通过在 <code>angular.json</code> 配置文件中将 <code>outputMode</code> 设置为 <code>static</code> 来选择退出此行为。</p>
<p>当 <code>outputMode</code> 设置为 <code>static</code> 时，Angular 会在构建时为每个路由生成预渲染的 HTML 文件，但它不会生成服务器文件，也不需要 Node.js 服务器来提供应用程序。这对于部署到不需要后端服务器的静态托管提供商非常有用。</p>
<p>要配置此项，请按以下方式更新您的 <code>angular.json</code> 文件：</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "projects"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "your-app"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "architect"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">        "build"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">          "options"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">            "outputMode"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"static"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">          }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div>
  <h2 id="caching-data-when-using-httpclient">
    <a href="#caching-data-when-using-httpclient" class="docs-anchor" tabindex="-1" aria-label="Link to Caching data when using HttpClient">使用 HttpClient 时缓存数据</a>
  </h2>
  <p><a href="api/common/http/HttpClient"></a><a href="/api/common/http/HttpClient"><code>HttpClient</code></a> 在服务器上运行时缓存了传出的网络请求。这些信息被序列化并通过服务器发送的初始 HTML 部分传输到浏览器。在浏览器中，<a href="/api/common/http/HttpClient"><code>HttpClient</code></a> 会检查缓存中是否有数据，如果有，则在初始应用程序渲染期间重用它，而不是发出新的 HTTP 请求。<a href="/api/common/http/HttpClient"><code>HttpClient</code></a> 一旦应用程序在浏览器中运行变为 <a href="api/core/ApplicationRef#isStable">稳定</a> 状态，就会停止使用缓存。</p>
<p>默认情况下，<a href="/api/common/http/HttpClient"><code>HttpClient</code></a> 会缓存所有不包含 <code>Authorization</code> 或 <code>Proxy-Authorization</code> 标头的 <code>HEAD</code> 和 <code>GET</code> 请求。您可以在提供水合作用时使用 <a href="api/platform-browser/withHttpTransferCacheOptions"></a><a href="/api/platform-browser/withHttpTransferCacheOptions"><code>withHttpTransferCacheOptions</code></a> 来重写这些设置。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/platform-browser/bootstrapApplication">bootstrapApplication</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(AppComponent, {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  providers: [</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    <a href="/api/platform-browser/provideClientHydration">provideClientHydration</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/platform-browser/withHttpTransferCacheOptions">withHttpTransferCacheOptions</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      includePostRequests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">true</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }))</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  ]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">});</span></span></code></pre>
  </div>
  <h2 id="configuring-a-server">
    <a href="#configuring-a-server" class="docs-anchor" tabindex="-1" aria-label="Link to Configuring a server">配置服务器</a>
  </h2>
  
  <h3 id="nodejs">
    <a href="#nodejs" class="docs-anchor" tabindex="-1" aria-label="Link to Node.js">Node.js</a>
  </h3>
  <p><code>@angular/ssr/node</code> 扩展了 <code>@angular/ssr</code>，专门用于 Node.js 环境。它提供了更易于在 Node.js 应用程序中实现服务器端渲染的 API。有关函数和用法示例的完整列表，请参阅 <a href="api/ssr/node/AngularNodeAppEngine"><code>@angular/ssr/node</code> API 参考</a>。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// server.ts</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/ssr/node/AngularNodeAppEngine">AngularNodeAppEngine</a>, createNodeRequestHandler, writeResponseToNodeResponse } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr/node'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> express </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> 'express'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> express</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">();</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> angularApp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/node/AngularNodeAppEngine">AngularNodeAppEngine</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">();</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'*'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  angularApp</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(req)</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (response) {</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">        <a href="/api/ssr/node/writeResponseToNodeResponse">writeResponseToNodeResponse</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(response, res);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">        next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// Pass control to the next middleware</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    })</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(next);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">});</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">/**</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D"> * The request handler used by the Angular CLI (dev-server and during build).</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D"> */</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> reqHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/node/createNodeRequestHandler">createNodeRequestHandler</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(app);</span></span></code></pre>
  </div>
  <h3 id="non-nodejs">
    <a href="#non-nodejs" class="docs-anchor" tabindex="-1" aria-label="Link to Non-Node.js">Non-Node.js</a>
  </h3>
  <p><code>@angular/ssr</code> 为在 Node.js 以外的平台上进行 Angular 应用程序的服务器端渲染提供了必要的 API。它利用 Web API 的标准 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank"><code>Request</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank"><code>Response</code></a> 对象，使您能够将 Angular SSR 集成到各种服务器环境中。有关详细信息和示例，请参阅 <a href="api/ssr/AngularAppEngine"><code>@angular/ssr</code> API 参考</a>。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// server.ts</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/ssr/AngularAppEngine">AngularAppEngine</a>, createRequestHandler } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/ssr'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> angularApp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/AngularAppEngine">AngularAppEngine</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">();</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">/**</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D"> * This is a request handler used by the Angular CLI (dev-server and during build).</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D"> */</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> reqHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/ssr/createRequestHandler">createRequestHandler</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> angularApp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(req);</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // ...</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">});</span></span></code></pre>
  </div>