
    <header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">Angular application build system</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/tools/cli/build-system-migration.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p>In v17 and higher, the new build system provides an improved way to build Angular applications. This new build system includes:</p>

  <ul class="docs-list">
    <li>A modern output format using ESM, with dynamic import expressions to support lazy module loading.</li>
<li>Faster build-time performance for both initial builds and incremental rebuilds.</li>
<li>Newer JavaScript ecosystem tools such as <a href="https://esbuild.github.io/" target="_blank">esbuild</a> and <a href="https://vitejs.dev/" target="_blank">Vite</a>.</li>
<li>Integrated SSR and prerendering capabilities.</li>
<li>Automatic global and component stylesheet hot replacement.</li>

  </ul>
  <p>This new build system is stable and fully supported for use with Angular applications.
You can migrate to the new build system with applications that use the <code>browser</code> builder.
If using a custom builder, please refer to the documentation for that builder on possible migration options.</p>

    <div class="docs-alert docs-alert-important">
    <p><strong>IMPORTANT:</strong> The existing webpack-based build system is still considered stable and fully supported.
Applications can continue to use the <code>browser</code> builder and projects can opt-out of migrating during an update.</p>

    </div>
    
  <h2 id="for-new-applications">
    <a href="#for-new-applications" class="docs-anchor" tabindex="-1" aria-label="Link to For new applications">For new applications</a>
  </h2>
  <p>New applications will use this new build system by default via the <code>application</code> builder.</p>

  <h2 id="for-existing-applications">
    <a href="#for-existing-applications" class="docs-anchor" tabindex="-1" aria-label="Link to For existing applications">For existing applications</a>
  </h2>
  <p>Both automated and manual procedures are available depending on the requirements of the project.
Starting with v18, the update process will ask if you would like to migrate existing applications to use the new build system via the automated migration.
Prior to migrating, please consider reviewing the <a href="#known-issues">Known Issues</a> section as it may contain relevant information for your project.</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>HELPFUL:</strong> Remember to remove any CommonJS assumptions in the application server code if using SSR such as <code>require</code>, <code>__filename</code>, <code>__dirname</code>, or other constructs from the <a href="https://nodejs.org/api/modules.html#the-module-scope" target="_blank">CommonJS module scope</a>. All application code should be ESM compatible. This does not apply to third-party dependencies.</p>

    </div>
    
  <h3 id="automated-migration-recommended">
    <a href="#automated-migration-recommended" class="docs-anchor" tabindex="-1" aria-label="Link to Automated migration (Recommended)">Automated migration (Recommended)</a>
  </h3>
  <p>The automated migration will adjust both the application configuration within <code>angular.json</code> as well as code and stylesheets to remove previous webpack-specific feature usage.
While many changes can be automated and most applications will not require any further changes, each application is unique and there may be some manual changes required.
After the migration, please attempt a build of the application as there could be new errors that will require adjustments within the code.
The errors will attempt to provide solutions to the problem when possible and the later sections of this guide describe some of the more common situations that you may encounter.
When updating to Angular v18 via <code>ng update</code>, you will be asked to execute the migration.
This migration is entirely optional for v18 and can also be run manually at anytime after an update via the following command:</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> update</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> @angular/cli</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> use-application-builder</span></span></code></pre>
  </div><p>The migration does the following:</p>

  <ul class="docs-list">
    <li>Converts existing <code>browser</code> or <code>browser-esbuild</code> target to <code>application</code></li>
<li>Removes any previous SSR builders (because <code>application</code> does that now).</li>
<li>Updates configuration accordingly.</li>
<li>Merges <code>tsconfig.server.json</code> with <code>tsconfig.app.json</code> and adds the TypeScript option <code>&quot;esModuleInterop&quot;: true</code> to ensure <code>express</code> imports are <a href="#esm-default-imports-vs-namespace-imports">ESM compliant</a>.</li>
<li>Updates application server code to use new bootstrapping and output directory structure.</li>
<li>Removes any webpack-specific builder stylesheet usage such as the tilde or caret in <code>@import</code>/<code>url()</code> and updates the configuration to provide equivalent behavior</li>
<li>Converts to use the new lower dependency <code>@angular/build</code> Node.js package if no other <code>@angular-devkit/build-angular</code> usage is found.</li>

  </ul>
  
  <h3 id="manual-migration">
    <a href="#manual-migration" class="docs-anchor" tabindex="-1" aria-label="Link to Manual migration">Manual migration</a>
  </h3>
  <p>Additionally for existing projects, you can manually opt-in to use the new builder on a per-application basis with two different options.
Both options are considered stable and fully supported by the Angular team.
The choice of which option to use is a factor of how many changes you will need to make to migrate and what new features you would like to use in the project.</p>

  <ul class="docs-list">
    <li>The <code>browser-esbuild</code> builder builds only the client-side bundle of an application designed to be compatible with the existing <code>browser</code> builder that provides the preexisting build system.
This builder provides equivalent build options, and in many cases, it serves as a drop-in replacement for existing <code>browser</code> applications.</li>
<li>The <code>application</code> builder covers an entire application, such as the client-side bundle, as well as optionally building a server for server-side rendering and performing build-time prerendering of static pages.</li>

  </ul>
  <p>The <code>application</code> builder is generally preferred as it improves server-side rendered (SSR) builds, and makes it easier for client-side rendered projects to adopt SSR in the future.
However it requires a little more migration effort, particularly for existing SSR applications if performed manually.
If the <code>application</code> builder is difficult for your project to adopt, <code>browser-esbuild</code> can be an easier solution which gives most of the build performance benefits with fewer breaking changes.</p>

  <h4 id="manual-migration-to-the-compatibility-builder">
    <a href="#manual-migration-to-the-compatibility-builder" class="docs-anchor" tabindex="-1" aria-label="Link to Manual migration to the compatibility builder">Manual migration to the compatibility builder</a>
  </h4>
  <p>A builder named <code>browser-esbuild</code> is available within the <code>@angular-devkit/build-angular</code> package that is present in an Angular CLI generated application.
You can try out the new build system for applications that use the <code>browser</code> builder.
If using a custom builder, please refer to the documentation for that builder on possible migration options.</p>
<p>The compatibility option was implemented to minimize the amount of changes necessary to initially migrate your applications.
This is provided via an alternate builder (<code>browser-esbuild</code>).
You can update the <code>build</code> target for any application target to migrate to the new build system.</p>
<p>The following is what you would typically find in <code>angular.json</code> for an application:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">...</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"architect"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "build"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular-devkit/build-angular:browser"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">...</span></span></code></pre>
  </div><p>Changing the <code>builder</code> field is the only change you will need to make.</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">...</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"architect"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "build"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular-devkit/build-angular:browser-esbuild"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">...</span></span></code></pre>
  </div>
  <h4 id="manual-migration-to-the-new-application-builder">
    <a href="#manual-migration-to-the-new-application-builder" class="docs-anchor" tabindex="-1" aria-label="Link to Manual migration to the new <code>application</code> builder">Manual migration to the new <code>application</code> builder</a>
  </h4>
  <p>A builder named <code>application</code> is also available within the <code>@angular-devkit/build-angular</code> package that is present in an Angular CLI generated application.
This builder is the default for all new applications created via <code>ng new</code>.</p>
<p>The following is what you would typically find in <code>angular.json</code> for an application:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">...</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"architect"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "build"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular-devkit/build-angular:browser"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">...</span></span></code></pre>
  </div><p>Changing the <code>builder</code> field is the first change you will need to make.</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">...</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"architect"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "build"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular-devkit/build-angular:application"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">...</span></span></code></pre>
  </div><p>Once the builder name has been changed, options within the <code>build</code> target will need to be updated.
The following list discusses all the <code>browser</code> builder options that will need to be adjusted.</p>

  <ul class="docs-list">
    <li><code>main</code> should be renamed to <code>browser</code>.</li>
<li><code>polyfills</code> should be an array, rather than a single file.</li>
<li><code>buildOptimizer</code> should be removed, as this is covered by the <code>optimization</code> option.</li>
<li><code>resourcesOutputPath</code> should be removed, this is now always <code>media</code>.</li>
<li><code>vendorChunk</code> should be removed, as this was a performance optimization which is no longer needed.</li>
<li><code>commonChunk</code> should be removed, as this was a performance optimization which is no longer needed.</li>
<li><code>deployUrl</code> should be removed and is not supported. Prefer <a href="guide/routing/common-router-tasks"><code>&lt;base href&gt;</code></a> instead. See <a href="tools/cli/deployment#--deploy-url">deployment documentation</a> for more information.</li>
<li><code>ngswConfigPath</code> should be renamed to <code>serviceWorker</code>.</li>

  </ul>
  <p>If the application is not using SSR currently, this should be the final step to allow <code>ng build</code> to function.
After executing <code>ng build</code> for the first time, there may be new warnings or errors based on behavioral differences or application usage of webpack-specific features.
Many of the warnings will provide suggestions on how to remedy that problem.
If it appears that a warning is incorrect or the solution is not apparent, please open an issue on <a href="https://github.com/angular/angular-cli/issues" target="_blank">GitHub</a>.
Also, the later sections of this guide provide additional information on several specific cases as well as current known issues.</p>
<p>For applications new to SSR, the <a href="guide/ssr">Angular SSR Guide</a> provides additional information regarding the setup process for adding SSR to an application.</p>
<p>For applications that are already using SSR, additional adjustments will be needed to update the application server to support the new integrated SSR capabilities.
The <code>application</code> builder now provides the integrated functionality for all of the following preexisting builders:</p>

  <ul class="docs-list">
    <li><code>app-shell</code></li>
<li><code>prerender</code></li>
<li><code>server</code></li>
<li><code>ssr-dev-server</code></li>

  </ul>
  <p>The <code>ng update</code> process will automatically remove usages of the <code>@nguniversal</code> scope packages where some of these builders were previously located.
The new <code>@angular/ssr</code> package will also be automatically added and used with configuration and code being adjusted during the update.
The <code>@angular/ssr</code> package supports the <code>browser</code> builder as well as the <code>application</code> builder.</p>

  <h2 id="executing-a-build">
    <a href="#executing-a-build" class="docs-anchor" tabindex="-1" aria-label="Link to Executing a build">Executing a build</a>
  </h2>
  <p>Once you have updated the application configuration, builds can be performed using <code>ng build</code> as was previously done.
Depending on the choice of builder migration, some of the command line options may be different.
If the build command is contained in any <code>npm</code> or other scripts, ensure they are reviewed and updated.
For applications that have migrated to the <code>application</code> builder and that use SSR and/or prererending, you also may be able to remove extra <code>ng run</code> commands from scripts now that <code>ng build</code> has integrated SSR support.</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> build</span></span></code></pre>
  </div>
  <h2 id="starting-the-development-server">
    <a href="#starting-the-development-server" class="docs-anchor" tabindex="-1" aria-label="Link to Starting the development server">Starting the development server</a>
  </h2>
  <p>The development server will automatically detect the new build system and use it to build the application.
To start the development server no changes are necessary to the <code>dev-server</code> builder configuration or command line.</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> serve</span></span></code></pre>
  </div><p>You can continue to use the <a href="/cli/serve">command line options</a> you have used in the past with the development server.</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>HELPFUL:</strong> With the development server, you may see a small Flash of Unstyled Content (FOUC) on startup as the server initializes.
The development server attempts to defer processing of stylesheets until first use to improve rebuild times.
This will not occur in builds outside the development server.</p>

    </div>
    
  <h3 id="hot-module-replacement">
    <a href="#hot-module-replacement" class="docs-anchor" tabindex="-1" aria-label="Link to Hot module replacement">Hot module replacement</a>
  </h3>
  <p>Hot Module Replacement (HMR) is a technique used by development servers to avoid reloading the entire page when only part of an application is changed.
The changes in many cases can be immediately shown in the browser which allows for an improved edit/refresh cycle while developing an application.
While general JavaScript-based hot module replacement (HMR) is currently not supported, several more specific forms of HMR are available:</p>

  <ul class="docs-list">
    <li><strong>global stylesheet</strong> (<code>styles</code> build option)</li>
<li><strong>component stylesheet</strong> (inline and file-based)</li>
<li><strong>component template</strong> (inline and file-based)</li>

  </ul>
  <p>The HMR capabilities are automatically enabled and require no code or configuration changes to use.
Angular provides HMR support for both file-based (<code>templateUrl</code>/<code>styleUrl</code>/<code>styleUrls</code>) and inline (<code>template</code>/<code>styles</code>) component styles and templates.
The build system will attempt to compile and process the minimal amount of application code when it detects a stylesheet only change.</p>
<p>If preferred, the HMR capabilities can be disabled by setting the <code>hmr</code> development server option to <code>false</code>.
This can also be changed on the command line via:</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> serve</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --no-hmr</span></span></code></pre>
  </div>
  <h3 id="vite-as-a-development-server">
    <a href="#vite-as-a-development-server" class="docs-anchor" tabindex="-1" aria-label="Link to Vite as a development server">Vite as a development server</a>
  </h3>
  <p>The usage of Vite in the Angular CLI is currently within a <em>development server capacity only</em>. Even without using the underlying Vite build system, Vite provides a full-featured development server with client side support that has been bundled into a low dependency npm package. This makes it an ideal candidate to provide comprehensive development server functionality. The current development server process uses the new build system to generate a development build of the application in memory and passes the results to Vite to serve the application. The usage of Vite, much like the Webpack-based development server, is encapsulated within the Angular CLI <code>dev-server</code> builder and currently cannot be directly configured.</p>

  <h3 id="prebundling">
    <a href="#prebundling" class="docs-anchor" tabindex="-1" aria-label="Link to Prebundling">Prebundling</a>
  </h3>
  <p>Prebundling provides improved build and rebuild times when using the development server.
Vite provides <a href="https://vite.dev/guide/dep-pre-bundling" target="_blank">prebundling capabilities</a> that are enabled by default when using the Angular CLI.
The prebundling process analyzes all the third-party project dependencies within a project and processes them the first time the development server is executed.
This process removes the need to rebuild and bundle the project's dependencies each time a rebuild occurs or the development server is executed.</p>
<p>In most cases, no additional customization is required. However, some situations where it may be needed include:</p>

  <ul class="docs-list">
    <li>Customizing loader behavior for imports within the dependency such as the <a href="#file-extension-loader-customization"><code>loader</code> option</a></li>
<li>Symlinking a dependency to local code for development such as <a href="https://docs.npmjs.com/cli/v10/commands/npm-link" target="_blank"><code>npm link</code></a></li>
<li>Working around an error encountered during prebundling of a dependency</li>

  </ul>
  <p>The prebundling process can be fully disabled or individual dependencies can be excluded if needed by a project.
The <code>dev-server</code> builder's <code>prebundle</code> option can be used for these customizations.
To exclude specific dependencies, the <code>prebundle.exclude</code> option is available:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"serve"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular/build:dev-server"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "options"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">        "prebundle"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">          "exclude"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"some-dep"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">]</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      },</span></span></code></pre>
  </div><p>By default, <code>prebundle</code> is set to <code>true</code> but can be set to <code>false</code> to fully disable prebundling.
However, excluding specific dependencies is recommended instead since rebuild times will increase with prebundling disabled.</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"serve"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular/build:dev-server"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "options"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">        "prebundle"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">false</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      },</span></span></code></pre>
  </div>
  <h2 id="new-features">
    <a href="#new-features" class="docs-anchor" tabindex="-1" aria-label="Link to New features">New features</a>
  </h2>
  <p>One of the main benefits of the application build system is the improved build and rebuild speed.
However, the new application build system also provides additional features not present in the <code>browser</code> builder.</p>

    <div class="docs-alert docs-alert-important">
    <p><strong>IMPORTANT:</strong> The new features of the <code>application</code> builder described here are incompatible with the <code>karma</code> test builder by default because it is using the <code>browser</code> builder internally.
Users can opt-in to use the <code>application</code> builder by setting the <code>builderMode</code> option to <code>application</code> for the <code>karma</code> builder.
This option is currently in developer preview.
If you notice any issues, please report them <a href="https://github.com/angular/angular-cli/issues" target="_blank">here</a>.</p>

    </div>
    
  <h3 id="build-time-value-replacement-with-define">
    <a href="#build-time-value-replacement-with-define" class="docs-anchor" tabindex="-1" aria-label="Link to Build-time value replacement with <code>define</code>">Build-time value replacement with <code>define</code></a>
  </h3>
  <p>The <code>define</code> option allows identifiers present in the code to be replaced with another value at build time.
This is similar to the behavior of Webpack's <code>DefinePlugin</code> which was previously used with some custom Webpack configurations that used third-party builders.
The option can either be used within the <code>angular.json</code> configuration file or on the command line.
Configuring <code>define</code> within <code>angular.json</code> is useful for cases where the values are constant and able to be checked in to source control.</p>
<p>Within the configuration file, the option is in the form of an object.
The keys of the object represent the identifier to replace and the values of the object represent the corresponding replacement value for the identifier.
An example is as follows:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"build"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular/build:application"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "options"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">      ...</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "define"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">          "SOME_NUMBER"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"5"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">          "ANOTHER"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"'this is a string literal, note the extra single quotes'"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">          "REFERENCE"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"globalThis.someValue.noteTheAbsentSingleQuotes"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span></code></pre>
  </div>
    <div class="docs-alert docs-alert-helpful">
    <p><strong>HELPFUL:</strong> All replacement values are defined as strings within the configuration file.
If the replacement is intended to be an actual string literal, it should be enclosed in single quote marks.
This allows the flexibility of using any valid JSON type as well as a different identifier as a replacement.</p>

    </div>
    <p>The command line usage is preferred for values that may change per build execution such as the git commit hash or an environment variable.
The CLI will merge <code>--define</code> values from the command line with <code>define</code> values from <code>angular.json</code>, including both in a build.
Command line usage takes precedence if the same identifier is present for both.
For command line usage, the <code>--define</code> option uses the format of <code>IDENTIFIER=VALUE</code>.</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --define</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> SOME_NUMBER=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">5</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --define</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> "ANOTHER='these will overwrite existing'"</span></span></code></pre>
  </div><p>Environment variables can also be selectively included in a build.
For non-Windows shells, the quotes around the hash literal can be escaped directly if preferred.
This example assumes a bash-like shell but similar behavior is available for other shells as well.</p>
<div class="docs-code shell">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> MY_APP_API_HOST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"http://example.com"</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> API_RETRY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">3</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ng</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --define</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> API_HOST=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">$MY_APP_API_HOST</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\'</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --define</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> API_RETRY=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">$API_RETRY</span></span></code></pre>
  </div><p>For either usage, TypeScript needs to be aware of the types for the identifiers to prevent type-checking errors during the build.
This can be accomplished with an additional type definition file within the application source code (<code>src/types.d.ts</code>, for example) with similar content:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> SOME_NUMBER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> ANOTHER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> GIT_HASH</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> API_HOST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> API_RETRY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span></code></pre>
  </div><p>The default project configuration is already setup to use any type definition files present in the project source directories.
If the TypeScript configuration for the project has been altered, it may need to be adjusted to reference this newly added type definition file.</p>

    <div class="docs-alert docs-alert-important">
    <p><strong>IMPORTANT:</strong> This option will not replace identifiers contained within Angular metadata such as a Component or Directive decorator.</p>

    </div>
    
  <h3 id="file-extension-loader-customization">
    <a href="#file-extension-loader-customization" class="docs-anchor" tabindex="-1" aria-label="Link to File extension loader customization">File extension loader customization</a>
  </h3>
  
    <div class="docs-alert docs-alert-important">
    <p><strong>IMPORTANT:</strong> This feature is only available with the <code>application</code> builder.</p>

    </div>
    <p>Some projects may need to control how all files with a specific file extension are loaded and bundled into an application.
When using the <code>application</code> builder, the <code>loader</code> option can be used to handle these cases.
The option allows a project to define the type of loader to use with a specified file extension.
A file with the defined extension can then be used within the application code via an import statement or dynamic import expression.
The available loaders that can be used are:</p>

  <ul class="docs-list">
    <li><code>text</code> - inlines the content as a <code>string</code> available as the default export</li>
<li><code>binary</code> - inlines the content as a <code>Uint8Array</code> available as the default export</li>
<li><code>file</code> - emits the file at the application output path and provides the runtime location of the file as the default export</li>
<li><code>empty</code> - considers the content to be empty and will not include it in bundles</li>

  </ul>
  <p>The <code>empty</code> value, while less common, can be useful for compatibility of third-party libraries that may contain bundler-specific import usage that needs to be removed.
One case for this is side-effect imports (<code>import &#39;my.css&#39;;</code>) of CSS files which has no effect in a browser.
Instead, the project can use <code>empty</code> and then the CSS files can be added to the <code>styles</code> build option or use some other injection method.</p>
<p>The loader option is an object-based option with the keys used to define the file extension and the values used to define the loader type.</p>
<p>An example of the build option usage to inline the content of SVG files into the bundled application would be as follows:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"build"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "builder"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"@angular/build:application"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "options"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">      ...</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "loader"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">        ".svg"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"text"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span></code></pre>
  </div><p>An SVG file can then be imported:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> contents </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> './some-file.svg'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(contents); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// &lt;svg&gt;...&lt;/svg&gt;</span></span></code></pre>
  </div><p>Additionally, TypeScript needs to be aware of the module type for the import to prevent type-checking errors during the build. This can be accomplished with an additional type definition file within the application source code (<code>src/types.d.ts</code>, for example) with the following or similar content:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> "*.svg"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> content;</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>The default project configuration is already setup to use any type definition files (<code>.d.ts</code> files) present in the project source directories. If the TypeScript configuration for the project has been altered, the tsconfig may need to be adjusted to reference this newly added type definition file.</p>

  <h3 id="import-attribute-loader-customization">
    <a href="#import-attribute-loader-customization" class="docs-anchor" tabindex="-1" aria-label="Link to Import attribute loader customization">Import attribute loader customization</a>
  </h3>
  <p>For cases where only certain files should be loaded in a specific way, per file control over loading behavior is available.
This is accomplished with a <code>loader</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with" target="_blank">import attribute</a> that can be used with both import statements and expressions.
The presence of the import attribute takes precedence over all other loading behavior including JS/TS and any <code>loader</code> build option values.
For general loading for all files of an otherwise unsupported file type, the <a href="#file-extension-loader-customization"><code>loader</code></a> build option is recommended.</p>
<p>For the import attribute, the following loader values are supported:</p>

  <ul class="docs-list">
    <li><code>text</code> - inlines the content as a <code>string</code> available as the default export</li>
<li><code>binary</code> - inlines the content as a <code>Uint8Array</code> available as the default export</li>
<li><code>file</code> - emits the file at the application output path and provides the runtime location of the file as the default export</li>

  </ul>
  <p>An additional requirement to use import attributes is that the TypeScript <code>module</code> option must be set to <code>esnext</code> to allow TypeScript to successfully build the application code.
Once <code>ES2025</code> is available within TypeScript, this change will no longer be needed.</p>
<p>At this time, TypeScript does not support type definitions that are based on import attribute values.
The use of <code>@ts-expect-error</code>/<code>@ts-ignore</code> or the use of individual type definition files (assuming the file is only imported with the same loader attribute) is currently required.
As an example, an SVG file can be imported as text via:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// @ts-expect-error TypeScript cannot provide types based on attributes yet</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> contents </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> './some-file.svg'</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { loader: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'text'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> };</span></span></code></pre>
  </div><p>The same can be accomplished with an import expression inside an async function.</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> loadSvg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt; {</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // @ts-expect-error TypeScript cannot provide types based on attributes yet</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'./some-file.svg'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, { with: { loader: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'text'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> } }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> m.default);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>For the import expression, the <code>loader</code> value must be a string literal to be statically analyzed.
A warning will be issued if the value is not a string literal.</p>
<p>The <code>file</code> loader is useful when a file will be loaded at runtime through either a <code>fetch()</code>, setting to an image elements <code>src</code>, or other similar method.</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// @ts-expect-error TypeScript cannot provide types based on attributes yet</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> imagePath </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> './image.webp'</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { loader: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'file'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> };</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(imagePath); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">// media/image-ULK2SIIB.webp</span></span></code></pre>
  </div><p>For production builds as shown in the code comment above, hashing will be automatically added to the path for long-term caching.</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>HELPFUL:</strong> When using the development server and using a <code>loader</code> attribute to import a file from a Node.js package, that package must be excluded from prebundling via the development server <code>prebundle</code> option.</p>

    </div>
    
  <h3 id="import-export-conditions">
    <a href="#import-export-conditions" class="docs-anchor" tabindex="-1" aria-label="Link to Import/export conditions">Import/export conditions</a>
  </h3>
  <p>Projects may need to map certain import paths to different files based on the type of build.
This can be particularly useful for cases such as <code>ng serve</code> needing to use debug/development specific code but <code>ng build</code> needing to use code without any development features/information.
Several import/export <a href="https://nodejs.org/api/packages.html#community-conditions-definitions" target="_blank">conditions</a> are automatically applied to support these project needs:</p>

  <ul class="docs-list">
    <li>For optimized builds, the <code>production</code> condition is enabled.</li>
<li>For non-optimized builds, the <code>development</code> condition is enabled.</li>
<li>For browser output code, the <code>browser</code> condition is enabled.</li>

  </ul>
  <p>An optimized build is determined by the value of the <code>optimization</code> option.
When <code>optimization</code> is set to <code>true</code> or more specifically if <code>optimization.scripts</code> is set to <code>true</code>, then the build is considered optimized.
This classification applies to both <code>ng build</code> and <code>ng serve</code>.
In a new project, <code>ng build</code> defaults to optimized and <code>ng serve</code> defaults to non-optimized.</p>
<p>A useful method to leverage these conditions within application code is to combine them with <a href="https://nodejs.org/api/packages.html#subpath-imports" target="_blank">subpath imports</a>.
By using the following import statement:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {verboseLogging} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '#logger'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span></code></pre>
  </div><p>The file can be switched in the <code>imports</code> field in <code>package.json</code>:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">  ...</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "imports"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "#logger"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "development"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./src/logging/debug.ts"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "default"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./src/logging/noop.ts"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>For applications that are also using SSR, browser and server code can be switched by using the <code>browser</code> condition:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic">  ...</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  "imports"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">    "#crashReporter"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "browser"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./src/browser-logger.ts"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">      "default"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./src/server-logger.ts"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>These conditions also apply to Node.js packages and any defined <a href="https://nodejs.org/api/packages.html#conditional-exports" target="_blank"><code>exports</code></a> within the packages.</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>HELPFUL:</strong> If currently using the <code>fileReplacements</code> build option, this feature may be able to replace its usage.</p>

    </div>
    
  <h2 id="known-issues">
    <a href="#known-issues" class="docs-anchor" tabindex="-1" aria-label="Link to Known Issues">Known Issues</a>
  </h2>
  <p>There are currently several known issues that you may encounter when trying the new build system. This list will be updated to stay current. If any of these issues are currently blocking you from trying out the new build system, please check back in the future as it may have been solved.</p>

  <h3 id="type-checking-of-web-worker-code-and-processing-of-nested-web-workers">
    <a href="#type-checking-of-web-worker-code-and-processing-of-nested-web-workers" class="docs-anchor" tabindex="-1" aria-label="Link to Type-checking of Web Worker code and processing of nested Web Workers">Type-checking of Web Worker code and processing of nested Web Workers</a>
  </h3>
  <p>Web Workers can be used within application code using the same syntax (<code>new Worker(new URL(&#39;&lt;workerfile&gt;&#39;, import.meta.url))</code>) that is supported with the <code>browser</code> builder.
However, the code within the Worker will not currently be type-checked by the TypeScript compiler. TypeScript code is supported just not type-checked.
Additionally, any nested workers will not be processed by the build system. A nested worker is a Worker instantiation within another Worker file.</p>

  <h3 id="esm-default-imports-vs-namespace-imports">
    <a href="#esm-default-imports-vs-namespace-imports" class="docs-anchor" tabindex="-1" aria-label="Link to ESM default imports vs. namespace imports">ESM default imports vs. namespace imports</a>
  </h3>
  <p>TypeScript by default allows default exports to be imported as namespace imports and then used in call expressions.
This is unfortunately a divergence from the ECMAScript specification.
The underlying bundler (<code>esbuild</code>) within the new build system expects ESM code that conforms to the specification.
The build system will now generate a warning if your application uses an incorrect type of import of a package.
However, to allow TypeScript to accept the correct usage, a TypeScript option must be enabled within the application's <code>tsconfig</code> file.
When enabled, the <a href="https://www.typescriptlang.org/tsconfig#esModuleInterop" target="_blank"><code>esModuleInterop</code></a> option provides better alignment with the ECMAScript specification and is also recommended by the TypeScript team.
Once enabled, you can update package imports where applicable to an ECMAScript conformant form.</p>
<p>Using the <a href="https://npmjs.com/package/moment" target="_blank"><code>moment</code></a> package as an example, the following application code will cause runtime errors:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> moment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> 'moment'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">moment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">());</span></span></code></pre>
  </div><p>The build will generate a warning to notify you that there is a potential problem. The warning will be similar to:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span>▲ [WARNING] Calling "moment" will crash at run-time because it's an import namespace object, not a function [call-import-namespace]</span></span><span class="line"><span></span></span><span class="line"><span>    src/main.ts:2:12:</span></span><span class="line"><span>      2 │ console.log(moment().format());</span></span><span class="line"><span>        ╵             ~~~~~~</span></span><span class="line"><span></span></span><span class="line"><span>Consider changing "moment" to a default import instead:</span></span><span class="line"><span></span></span><span class="line"><span>    src/main.ts:1:7:</span></span><span class="line"><span>      1 │ import * as moment from 'moment';</span></span><span class="line"><span>        │        ~~~~~~~~~~~</span></span><span class="line"><span>        ╵        moment</span></span></code></pre>
  </div><p>However, you can avoid the runtime errors and the warning by enabling the <code>esModuleInterop</code> TypeScript option for the application and changing the import to the following:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> moment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> 'moment'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">moment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">());</span></span></code></pre>
  </div>
  <h3 id="order-dependent-side-effectful-imports-in-lazy-modules">
    <a href="#order-dependent-side-effectful-imports-in-lazy-modules" class="docs-anchor" tabindex="-1" aria-label="Link to Order-dependent side-effectful imports in lazy modules">Order-dependent side-effectful imports in lazy modules</a>
  </h3>
  <p>Import statements that are dependent on a specific ordering and are also used in multiple lazy modules can cause top-level statements to be executed out of order.
This is not common as it depends on the usage of side-effectful modules and does not apply to the <code>polyfills</code> option.
This is caused by a <a href="https://github.com/evanw/esbuild/issues/399" target="_blank">defect</a> in the underlying bundler but will be addressed in a future update.</p>

    <div class="docs-alert docs-alert-important">
    <p><strong>IMPORTANT:</strong> Avoiding the use of modules with non-local side effects (outside of polyfills) is recommended whenever possible regardless of the build system being used and avoids this particular issue. Modules with non-local side effects can have a negative effect on both application size and runtime performance as well.</p>

    </div>
    
  <h2 id="bug-reports">
    <a href="#bug-reports" class="docs-anchor" tabindex="-1" aria-label="Link to Bug reports">Bug reports</a>
  </h2>
  <p>Report issues and feature requests on <a href="https://github.com/angular/angular-cli/issues" target="_blank">GitHub</a>.</p>
<p>Please provide a minimal reproduction where possible to aid the team in addressing issues.</p>
