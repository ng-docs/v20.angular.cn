
    <header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">Angular package format</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/tools/libraries/angular-package-format.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p>This document describes the Angular Package Format (APF).
APF is an Angular specific specification for the structure and format of npm packages that is used by all first-party Angular packages (<code>@angular/core</code>, <code>@angular/material</code>, etc.) and most third-party Angular libraries.</p>
<p>APF enables a package to work seamlessly under most common scenarios that use Angular.
Packages that use APF are compatible with the tooling offered by the Angular team as well as wider JavaScript ecosystem.
It is recommended that third-party library developers follow the same npm package format.</p>

    <div class="docs-alert docs-alert-helpful">
    <p><strong>HELPFUL:</strong> APF is versioned along with the rest of Angular, and every major version improves the package format.
You can find the versions of the specification prior to v13 in this <a href="https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/preview" target="_blank">google doc</a>.</p>

    </div>
    
  <h2 id="why-specify-a-package-format">
    <a href="#why-specify-a-package-format" class="docs-anchor" tabindex="-1" aria-label="Link to Why specify a package format?">Why specify a package format?</a>
  </h2>
  <p>In today's JavaScript landscape, developers consume packages in many different ways, using many different toolchains (webpack, Rollup, esbuild, etc.).
These tools may understand and require different inputs - some tools may be able to process the latest ES language version, while others may benefit from directly consuming an older ES version.</p>
<p>The Angular distribution format supports all of the commonly used development tools and workflows, and adds emphasis on optimizations that result either in smaller application payload size or faster development iteration cycle (build time).</p>
<p>Developers can rely on Angular CLI and <a href="https://github.com/ng-packagr/ng-packagr" target="_blank">ng-packagr</a> (a build tool Angular CLI uses) to produce packages in the Angular package format.
See the <a href="tools/libraries/creating-libraries">Creating Libraries</a> guide for more details.</p>

  <h2 id="file-layout">
    <a href="#file-layout" class="docs-anchor" tabindex="-1" aria-label="Link to File layout">File layout</a>
  </h2>
  <p>The following example shows a simplified version of the <code>@angular/core</code> package's file layout, with an explanation for each file in the package.</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">node_modules/@angular/core</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">├── README.md</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">├── package.json</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">├── index.d.ts</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">├── fesm2022</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">│   ├── core.mjs</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">│   ├── core.mjs.map</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">│   ├── testing.mjs</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">│   └── testing.mjs.map</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">└── testing</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    └── index.d.ts</span></span></code></pre>
  </div><p>This table describes the file layout under <code>node_modules/@angular/core</code> annotated to describe the purpose of files and directories:</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left">Files</th>
<th align="left">Purpose</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left"><code>README.md</code></td>
<td align="left">Package README, used by npmjs web UI.</td>
</tr>
<tr>
<td align="left"><code>package.json</code></td>
<td align="left">Primary <code>package.json</code>, describing the package itself as well as all available entrypoints and code formats. This file contains the "exports" mapping used by runtimes and tools to perform module resolution.</td>
</tr>
<tr>
<td align="left"><code>index.d.ts</code></td>
<td align="left">Bundled <code>.d.ts</code> for the primary entrypoint <code>@angular/core</code>.</td>
</tr>
<tr>
<td align="left"><code>fesm2022/</code> <br /> &nbsp;&nbsp;─ <code>core.mjs</code> <br /> &nbsp;&nbsp;─ <code>core.mjs.map</code> <br /> &nbsp;&nbsp;─ <code>testing.mjs</code> <br /> &nbsp;&nbsp;─ <code>testing.mjs.map</code></td>
<td align="left">Code for all entrypoints in flattened (FESM) ES2022 format, along with source maps.</td>
</tr>
<tr>
<td align="left"><code>testing/</code></td>
<td align="left">Directory representing the "testing" entrypoint.</td>
</tr>
<tr>
<td align="left"><code>testing/index.d.ts</code></td>
<td align="left">Bundled <code>.d.ts</code> for the <code>@angular/core/testing</code> entrypoint.</td>
</tr>

      </tbody>
    </table>
  </div>
  
  <h2 id="packagejson">
    <a href="#packagejson" class="docs-anchor" tabindex="-1" aria-label="Link to <code>package.json</code>"><code>package.json</code></a>
  </h2>
  <p>The primary <code>package.json</code> contains important package metadata, including the following:</p>

  <ul class="docs-list">
    <li><p>It <a href="#esm-declaration">declares</a> the package to be in EcmaScript Module (ESM) format</p>
</li>
<li><p>It contains an <a href="#exports"><code>&quot;exports&quot;</code> field</a> which defines the available source code formats of all entrypoints</p>
</li>
<li><p>It contains <a href="#legacy-resolution-keys">keys</a> which define the available source code formats of the primary <code>@angular/core</code> entrypoint, for tools which do not understand <code>&quot;exports&quot;</code>.
  These keys are considered deprecated, and could be removed as the support for <code>&quot;exports&quot;</code> rolls out across the ecosystem.</p>
</li>
<li><p>It declares whether the package contains <a href="#side-effects">side effects</a></p>
</li>

  </ul>
  
  <h3 id="esm-declaration">
    <a href="#esm-declaration" class="docs-anchor" tabindex="-1" aria-label="Link to ESM declaration">ESM declaration</a>
  </h3>
  <p>The top-level <code>package.json</code> contains the key:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "type"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"module"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>This informs resolvers that code within the package is using EcmaScript Modules as opposed to CommonJS modules.</p>

  <h3 id="quotexportsquot">
    <a href="#quotexportsquot" class="docs-anchor" tabindex="-1" aria-label="Link to <code>&quot;exports&quot;</code>"><code>&quot;exports&quot;</code></a>
  </h3>
  <p>The <code>&quot;exports&quot;</code> field has the following structure:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"exports"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "./schematics/*"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "default"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./schematics/*.js"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "./package.json"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "default"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./package.json"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "."</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "types"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./core.d.ts"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "default"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./fesm2022/core.mjs"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "./testing"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "types"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./testing/testing.d.ts"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "default"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./fesm2022/testing.mjs"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>Of primary interest are the <code>&quot;.&quot;</code> and the <code>&quot;./testing&quot;</code> keys, which define the available code formats for the <code>@angular/core</code> primary entrypoint and the <code>@angular/core/testing</code> secondary entrypoint, respectively.
For each entrypoint, the available formats are:</p>

  <div class="docs-table docs-scroll-track-transparent">
    <table>
      <thead>
        <tr>
<th align="left">Formats</th>
<th align="left">Details</th>
</tr>

      </thead>
      <tbody>
        <tr>
<td align="left">Typings (<code>.d.ts</code> files)</td>
<td align="left"><code>.d.ts</code> files are used by TypeScript when depending on a given package.</td>
</tr>
<tr>
<td align="left"><code>default</code></td>
<td align="left">ES2022 code flattened into a single source.</td>
</tr>

      </tbody>
    </table>
  </div>
  <p>Tooling that is aware of these keys may preferentially select a desirable code format from <code>&quot;exports&quot;</code>.</p>
<p>Libraries may want to expose additional static files which are not captured by the exports of the JavaScript-based entry-points such as Sass mixins or pre-compiled CSS.</p>
<p>For more information, see <a href="tools/libraries/creating-libraries#managing-assets-in-a-library">Managing assets in a library</a>.</p>

  <h3 id="legacy-resolution-keys">
    <a href="#legacy-resolution-keys" class="docs-anchor" tabindex="-1" aria-label="Link to Legacy resolution keys">Legacy resolution keys</a>
  </h3>
  <p>In addition to <code>&quot;exports&quot;</code>, the top-level <code>package.json</code> also defines legacy module resolution keys for resolvers that don't support <code>&quot;exports&quot;</code>.
For <code>@angular/core</code> these are:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "module"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./fesm2022/core.mjs"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "typings"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"./core.d.ts"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>As shown in the preceding code snippet, a module resolver can use these keys to load a specific code format.</p>

  <h3 id="side-effects">
    <a href="#side-effects" class="docs-anchor" tabindex="-1" aria-label="Link to Side effects">Side effects</a>
  </h3>
  <p>The last function of <code>package.json</code> is to declare whether the package has <a href="#sideeffects-flag">side effects</a>.</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "sideEffects"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">false</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>Most Angular packages should not depend on top-level side effects, and thus should include this declaration.</p>

  <h2 id="entrypoints-and-code-splitting">
    <a href="#entrypoints-and-code-splitting" class="docs-anchor" tabindex="-1" aria-label="Link to Entrypoints and code splitting">Entrypoints and code splitting</a>
  </h2>
  <p>Packages in the Angular Package Format contain one primary entrypoint and zero or more secondary entrypoints (for example, <code>@angular/common/http</code>).
Entrypoints serve several functions.</p>

    <ol class="docs-ordered-list">
      <li><p>They define the module specifiers from which users import code (for example, <code>@angular/core</code> and <code>@angular/core/testing</code>).</p>
<p> Users typically perceive these entrypoints as distinct groups of symbols, with different purposes or capability.</p>
<p> Specific entrypoints might only be used for special purposes, such as testing.
 Such APIs can be separated out from the primary entrypoint to reduce the chance of them being used accidentally or incorrectly.</p>
</li>
<li><p>They define the granularity at which code can be lazily loaded.</p>
<p> Many modern build tools are only capable of "code splitting" (aka lazy loading) at the ES Module level.
 The Angular Package Format uses primarily a single "flat" ES Module per entry point. This means that most build tooling is not able to split code with a single entry point into multiple output chunks.</p>
</li>

    </ol>
    <p>The general rule for APF packages is to use entrypoints for the smallest sets of logically connected code possible.
For example, the Angular Material package publishes each logical component or set of components as a separate entrypoint - one for Button, one for Tabs, etc.
This allows each Material component to be lazily loaded separately, if desired.</p>
<p>Not all libraries require such granularity.
Most libraries with a single logical purpose should be published as a single entrypoint.
<code>@angular/core</code> for example uses a single entrypoint for the runtime, because the Angular runtime is generally used as a single entity.</p>

  <h3 id="resolution-of-secondary-entry-points">
    <a href="#resolution-of-secondary-entry-points" class="docs-anchor" tabindex="-1" aria-label="Link to Resolution of secondary entry points">Resolution of secondary entry points</a>
  </h3>
  <p>Secondary entrypoints can be resolved via the <code>&quot;exports&quot;</code> field of the <code>package.json</code> for the package.</p>

  <h2 id="readmemd">
    <a href="#readmemd" class="docs-anchor" tabindex="-1" aria-label="Link to README.md">README.md</a>
  </h2>
  <p>The README file in the Markdown format that is used to display description of a package on npm and GitHub.</p>
<p>Example README content of @angular/core package:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">Angular</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">=======</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">The sources for this package are in the main [Angular](https://github.com/angular/angular) repo.Please file issues and pull requests against that repo.</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">License: MIT</span></span></code></pre>
  </div>
  <h2 id="partial-compilation">
    <a href="#partial-compilation" class="docs-anchor" tabindex="-1" aria-label="Link to Partial compilation">Partial compilation</a>
  </h2>
  <p>Libraries in the Angular Package Format must be published in "partial compilation" mode.
This is a compilation mode for <code>ngc</code> which produces compiled Angular code that is not tied to a specific Angular runtime version, in contrast to the full compilation used for applications, where the Angular compiler and runtime versions must match exactly.</p>
<p>To partially compile Angular code, use the <code>compilationMode</code> flag in the <code>angularCompilerOptions</code> property of your <code>tsconfig.json</code>:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  …</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "angularCompilerOptions"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "compilationMode"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"partial"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>Partially compiled library code is then converted to fully compiled code during the application build process by the Angular CLI.</p>
<p>If your build pipeline does not use the Angular CLI then refer to the <a href="tools/libraries/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli">Consuming partial ivy code outside the Angular CLI</a> guide.</p>

  <h2 id="optimizations">
    <a href="#optimizations" class="docs-anchor" tabindex="-1" aria-label="Link to Optimizations">Optimizations</a>
  </h2>
  
  <h3 id="flattening-of-es-modules">
    <a href="#flattening-of-es-modules" class="docs-anchor" tabindex="-1" aria-label="Link to Flattening of ES modules">Flattening of ES modules</a>
  </h3>
  <p>The Angular Package Format specifies that code be published in "flattened" ES module format.
This significantly reduces the build time of Angular applications as well as download and parse time of the final application bundle.
Please check out the excellent post <a href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules" target="_blank">"The cost of small modules"</a> by Nolan Lawson.</p>
<p>The Angular compiler can generate index ES module files. Tools like Rollup can use these files to generate flattened modules in a <em>Flattened ES Module</em> (FESM) file format.</p>
<p>FESM is a file format created by flattening all ES Modules accessible from an entrypoint into a single ES Module.
It's formed by following all imports from a package and copying that code into a single file while preserving all public ES exports and removing all private imports.</p>
<p>The abbreviated name, FESM, pronounced <em>phe-som</em>, can be followed by a number such as FESM2020.
The number refers to the language level of the JavaScript inside the module.
Accordingly a FESM2022 file would be ESM+ES2022 and include import/export statements and ES2022 source code.</p>
<p>To generate a flattened ES Module index file, use the following configuration options in your tsconfig.json file:</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "compilerOptions"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    …</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "module"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"esnext"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "target"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"es2022"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    …</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  },</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  "angularCompilerOptions"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    …</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "flatModuleOutFile"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"my-ui-lib.js"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    "flatModuleId"</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">"my-ui-lib"</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  }</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>Once the index file (for example, <code>my-ui-lib.js</code>) is generated by ngc, bundlers and optimizers like Rollup can be used to produce the flattened ESM file.</p>

  <h3 id="sideeffects-flag">
    <a href="#sideeffects-flag" class="docs-anchor" tabindex="-1" aria-label="Link to "sideEffects" flag">"sideEffects" flag</a>
  </h3>
  <p>By default, EcmaScript Modules are side-effectful: importing from a module ensures that any code at the top level of that module should run.
This is often undesirable, as most side-effectful code in typical modules is not truly side-effectful, but instead only affects specific symbols.
If those symbols are not imported and used, it's often desirable to remove them in an optimization process known as tree-shaking, and the side-effectful code can prevent this.</p>
<p>Build tools such as webpack support a flag which allows packages to declare that they do not depend on side-effectful code at the top level of their modules, giving the tools more freedom to tree-shake code from the package.
The end result of these optimizations should be smaller bundle size and better code distribution in bundle chunks after code-splitting.
This optimization can break your code if it contains non-local side-effects - this is however not common in Angular applications and it's usually a sign of bad design.
The recommendation is for all packages to claim the side-effect free status by setting the <code>sideEffects</code> property to <code>false</code>, and that developers follow the <a href="/style-guide">Angular Style Guide</a> which naturally results in code without non-local side-effects.</p>
<p>More info: <a href="https://github.com/webpack/webpack/tree/master/examples/side-effects" target="_blank">webpack docs on side effects</a></p>

  <h3 id="es2022-language-level">
    <a href="#es2022-language-level" class="docs-anchor" tabindex="-1" aria-label="Link to ES2022 language level">ES2022 language level</a>
  </h3>
  <p>ES2022 Language level is now the default language level that is consumed by Angular CLI and other tooling.
The Angular CLI down-levels the bundle to a language level that is supported by all targeted browsers at application build time.</p>

  <h3 id="dts-bundling---type-definition-flattening">
    <a href="#dts-bundling---type-definition-flattening" class="docs-anchor" tabindex="-1" aria-label="Link to d.ts bundling / type definition flattening">d.ts bundling / type definition flattening</a>
  </h3>
  <p>As of APF v8, it is recommended to bundle TypeScript definitions.
Bundling of type definitions can significantly speed up compilations for users, especially if there are many individual <code>.ts</code> source files in your library.</p>
<p>Angular uses <a href="https://github.com/Swatinem/rollup-plugin-dts" target="_blank"><code>rollup-plugin-dts</code></a> to flatten <code>.d.ts</code> files (using <code>rollup</code>, similar to how FESM files are created).</p>
<p>Using rollup for <code>.d.ts</code> bundling is beneficial as it supports code splitting between entry-points.
For example, consider you have multiple entrypoints relying on the same shared type, a shared <code>.d.ts</code> file would be created along with the larger flattened <code>.d.ts</code> files.
This is desirable and avoids duplication of types.</p>

  <h3 id="tslib">
    <a href="#tslib" class="docs-anchor" tabindex="-1" aria-label="Link to Tslib">Tslib</a>
  </h3>
  <p>As of APF v10, it is recommended to add tslib as a direct dependency of your primary entry-point.
This is because the tslib version is tied to the TypeScript version used to compile your library.</p>

  <h2 id="examples">
    <a href="#examples" class="docs-anchor" tabindex="-1" aria-label="Link to Examples">Examples</a>
  </h2>
  
    <nav class="docs-pill-row">
      
    <a class="docs-pill" href="https://unpkg.com/browse/@angular/core@17.0.0/" target="_blank">
      @angular/core package<docs-icon class="docs-icon-small">open_in_new</docs-icon>
    </a>
    
    <a class="docs-pill" href="https://unpkg.com/browse/@angular/material@17.0.0/" target="_blank">
      @angular/material package<docs-icon class="docs-icon-small">open_in_new</docs-icon>
    </a>
    

    </nav>
    
  <h2 id="definition-of-terms">
    <a href="#definition-of-terms" class="docs-anchor" tabindex="-1" aria-label="Link to Definition of terms">Definition of terms</a>
  </h2>
  <p>The following terms are used throughout this document intentionally.
In this section are the definitions of all of them to provide additional clarity.</p>

  <h3 id="package">
    <a href="#package" class="docs-anchor" tabindex="-1" aria-label="Link to Package">Package</a>
  </h3>
  <p>The smallest set of files that are published to NPM and installed together, for example <code>@angular/core</code>.
This package includes a manifest called package.json, compiled source code, typescript definition files, source maps, metadata, etc.
The package is installed with <code>npm install @angular/core</code>.</p>

  <h3 id="symbol">
    <a href="#symbol" class="docs-anchor" tabindex="-1" aria-label="Link to Symbol">Symbol</a>
  </h3>
  <p>A class, function, constant, or variable contained in a module and optionally made visible to the external world via a module export.</p>

  <h3 id="module">
    <a href="#module" class="docs-anchor" tabindex="-1" aria-label="Link to Module">Module</a>
  </h3>
  <p>Short for ECMAScript Modules.
A file containing statements that import and export symbols.
This is identical to the definition of modules in the ECMAScript spec.</p>

  <h3 id="esm">
    <a href="#esm" class="docs-anchor" tabindex="-1" aria-label="Link to ESM">ESM</a>
  </h3>
  <p>Short for ECMAScript Modules (see above).</p>

  <h3 id="fesm">
    <a href="#fesm" class="docs-anchor" tabindex="-1" aria-label="Link to FESM">FESM</a>
  </h3>
  <p>Short for Flattened ES Modules and consists of a file format created by flattening all ES Modules accessible from an entry point into a single ES Module.</p>

  <h3 id="module-id">
    <a href="#module-id" class="docs-anchor" tabindex="-1" aria-label="Link to Module ID">Module ID</a>
  </h3>
  <p>The identifier of a module used in the import statements (for example, <code>@angular/core</code>).
The ID often maps directly to a path on the filesystem, but this is not always the case due to various module resolution strategies.</p>

  <h3 id="module-specifier">
    <a href="#module-specifier" class="docs-anchor" tabindex="-1" aria-label="Link to Module specifier">Module specifier</a>
  </h3>
  <p>A module identifier (see above).</p>

  <h3 id="module-resolution-strategy">
    <a href="#module-resolution-strategy" class="docs-anchor" tabindex="-1" aria-label="Link to Module resolution strategy">Module resolution strategy</a>
  </h3>
  <p>Algorithm used to convert Module IDs to paths on the filesystem.
Node.js has one that is well specified and widely used, TypeScript supports several module resolution strategies, <a href="https://developers.google.com/closure/compiler" target="_blank">Closure Compiler</a> has yet another strategy.</p>

  <h3 id="module-format">
    <a href="#module-format" class="docs-anchor" tabindex="-1" aria-label="Link to Module format">Module format</a>
  </h3>
  <p>Specification of the module syntax that covers at minimum the syntax for the importing and exporting from a file.
Common module formats are CommonJS (CJS, typically used for Node.js applications) or ECMAScript Modules (ESM).
The module format indicates only the packaging of the individual modules, but not the JavaScript language features used to make up the module content.
Because of this, the Angular team often uses the language level specifier as a suffix to the module format, (for example, ESM+ES2022 specifies that the module is in ESM format and contains ES2022 code).</p>

  <h3 id="bundle">
    <a href="#bundle" class="docs-anchor" tabindex="-1" aria-label="Link to Bundle">Bundle</a>
  </h3>
  <p>An artifact in the form of a single JS file, produced by a build tool (for example, <a href="https://webpack.js.org" target="_blank">webpack</a> or <a href="https://rollupjs.org" target="_blank">Rollup</a>) that contains symbols originating in one or more modules.
Bundles are a browser-specific workaround that reduce network strain that would be caused if browsers were to start downloading hundreds if not tens of thousands of files.
Node.js typically doesn't use bundles.
Common bundle formats are UMD and System.register.</p>

  <h3 id="language-level">
    <a href="#language-level" class="docs-anchor" tabindex="-1" aria-label="Link to Language level">Language level</a>
  </h3>
  <p>The language of the code (ES2022).
Independent of the module format.</p>

  <h3 id="entry-point">
    <a href="#entry-point" class="docs-anchor" tabindex="-1" aria-label="Link to Entry point">Entry point</a>
  </h3>
  <p>A module intended to be imported by the user.
It is referenced by a unique module ID and exports the public API referenced by that module ID.
An example is <code>@angular/core</code> or <code>@angular/core/testing</code>.
Both entry points exist in the <code>@angular/core</code> package, but they export different symbols.
A package can have many entry points.</p>

  <h3 id="deep-import">
    <a href="#deep-import" class="docs-anchor" tabindex="-1" aria-label="Link to Deep import">Deep import</a>
  </h3>
  <p>A process of retrieving symbols from modules that are not Entry Points.
These module IDs are usually considered to be private APIs that can change over the lifetime of the project or while the bundle for the given package is being created.</p>

  <h3 id="top-level-import">
    <a href="#top-level-import" class="docs-anchor" tabindex="-1" aria-label="Link to Top-Level import">Top-Level import</a>
  </h3>
  <p>An import coming from an entry point.
The available top-level imports are what define the public API and are exposed in "@angular/name" modules, such as <code>@angular/core</code> or <code>@angular/common</code>.</p>

  <h3 id="tree-shaking">
    <a href="#tree-shaking" class="docs-anchor" tabindex="-1" aria-label="Link to Tree-shaking">Tree-shaking</a>
  </h3>
  <p>The process of identifying and removing code not used by an application - also known as dead code elimination.
This is a global optimization performed at the application level using tools like <a href="https://rollupjs.org" target="_blank">Rollup</a>, <a href="https://developers.google.com/closure/compiler" target="_blank">Closure Compiler</a>, or <a href="https://github.com/terser/terser" target="_blank">Terser</a>.</p>

  <h3 id="aot-compiler">
    <a href="#aot-compiler" class="docs-anchor" tabindex="-1" aria-label="Link to AOT compiler">AOT compiler</a>
  </h3>
  <p>The Ahead of Time Compiler for Angular.</p>

  <h3 id="flattened-type-definitions">
    <a href="#flattened-type-definitions" class="docs-anchor" tabindex="-1" aria-label="Link to Flattened type definitions">Flattened type definitions</a>
  </h3>
  <p>The bundled TypeScript definitions generated from <a href="https://api-extractor.com" target="_blank">API Extractor</a>.</p>
