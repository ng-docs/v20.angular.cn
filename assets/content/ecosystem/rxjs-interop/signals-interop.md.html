<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">Angular Signal 的 RxJS 互操作</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/ecosystem/rxjs-interop/signals-interop.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p><code>@angular/core/rxjs-interop</code> 包提供了帮助您集成 RxJS 和 Angular Signals 的 API。</p>

  <h2 id="create-a-signal-from-an-rxjs-observable-with-tosignal">
    <a href="#create-a-signal-from-an-rxjs-observable-with-tosignal" class="docs-anchor" tabindex="-1" aria-label="Link to Create a signal from an RxJs Observable with <code>toSignal</code>">使用 <code>toSignal</code> 从 RxJs 可观察者创建一个 Signal</a>
  </h2>
  <p>使用 <a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 函数来创建一个跟踪 Observable 值的 Signal。它的行为类似于模板中的 <code>async</code> pipe，但更灵活，并且可以在应用程序的任何地方使用。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/core/Component">Component</a> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/common/AsyncPipe">AsyncPipe</a> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/common'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { interval } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> 'rxjs'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/core/rxjs-interop/toSignal">toSignal</a> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core/rxjs-interop'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/Component">Component</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">`{{ counter() }}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> Ticker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  counterObservable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> interval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // Get a `Signal` representing the `counterObservable`'s value.</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  counter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/core/rxjs-interop/toSignal">toSignal</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.counterObservable, {initialValue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">});</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>与 <code>async</code> pipe 类似，<a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 会立即订阅 Observable，这可能会触发副作用。当调用 <a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 的组件或服务被销毁时，由 <a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 创建的订阅会自动从给定的 Observable 中取消订阅。</p>

    <div class="docs-alert docs-alert-important">
    <p><strong>重要提示：</strong> <a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 会创建一个订阅。您应该避免对同一个 Observable 重复调用它，而是复用它返回的 Signal。</p>

    </div>
    
  <h3 id="injection-context">
    <a href="#injection-context" class="docs-anchor" tabindex="-1" aria-label="Link to Injection context">注入上下文</a>
  </h3>
  <p><a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 默认需要在<a href="guide/di/dependency-injection-context">注入上下文</a>中运行，例如在组件或服务的构造期间。如果注入上下文不可用，您可以手动指定要使用的<a href="/api/core/Injector"><code>Injector</code></a>。</p>

  <h3 id="initial-values">
    <a href="#initial-values" class="docs-anchor" tabindex="-1" aria-label="Link to Initial values">初始值</a>
  </h3>
  <p>Observable 在订阅时可能不会同步产生值，但 Signal 始终需要一个当前值。有几种方法可以处理 <a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> Signal 的“初始”值。</p>

  <h4 id="the-initialvalue-option">
    <a href="#the-initialvalue-option" class="docs-anchor" tabindex="-1" aria-label="Link to The <code>initialValue</code> option"><code>initialValue</code> 选项</a>
  </h4>
  <p>如上面的范例所示，你可以使用 <code>initialValue</code> 选项指定 signal 在 Observable 首次发出之前应返回的值。</p>

  <h4 id="undefined-initial-values">
    <a href="#undefined-initial-values" class="docs-anchor" tabindex="-1" aria-label="Link to <code>undefined</code> initial values"><code>undefined</code> 初始值</a>
  </h4>
  <p>如果你不提供 <code>initialValue</code>，则生成的 signal 将返回 <code>undefined</code>，直到 Observable 发出值。这类似于 <code>async</code> 管道返回 <code>null</code> 的行为。</p>

  <h4 id="the-requiresync-option">
    <a href="#the-requiresync-option" class="docs-anchor" tabindex="-1" aria-label="Link to The <code>requireSync</code> option"><code>requireSync</code> 选项</a>
  </h4>
  <p>某些 Observable 保证同步发出值，例如 <code>BehaviorSubject</code>。在这些情况下，你可以指定 <code>requireSync: true</code> 选项。</p>
<p>当 <code>requiredSync</code> 为 <code>true</code> 时，<a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 会强制 Observable 在订阅时同步发出值。这保证了 Signal 始终有一个值，并且不需要 <code>undefined</code> 类型或初始值。</p>

  <h3 id="manualcleanup">
    <a href="#manualcleanup" class="docs-anchor" tabindex="-1" aria-label="Link to <code>manualCleanup</code>"><code>manualCleanup</code></a>
  </h3>
  <p>默认情况下，当创建它的组件或服务被销毁时，<a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 会自动从 Observable 中取消订阅。</p>
<p>要覆盖此行为，你可以传递 <code>manualCleanup</code> 选项。你可以将此设置用于那些自然完成的 Observable。</p>

  <h3 id="error-and-completion">
    <a href="#error-and-completion" class="docs-anchor" tabindex="-1" aria-label="Link to Error and Completion">错误和完成</a>
  </h3>
  <p>如果在 <a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 中使用的 Observable 产生错误，则在读取 Signal 时会抛出该错误。</p>
<p>如果在 <a href="/api/core/rxjs-interop/toSignal"><code>toSignal</code></a> 中使用的 Observable 完成，则 Signal 会继续返回完成之前的最新发出值。</p>

  <h2 id="create-an-rxjs-observable-from-a-signal-with-toobservable">
    <a href="#create-an-rxjs-observable-from-a-signal-with-toobservable" class="docs-anchor" tabindex="-1" aria-label="Link to Create an RxJS Observable from a signal with <code>toObservable</code>">使用 <code>toObservable</code> 从 Signal 创建一个 RxJS 可观察者</a>
  </h2>
  <p>使用 <a href="/api/core/rxjs-interop/toObservable"><code>toObservable</code></a> 工具来创建一个跟踪 Signal 值的 <code>Observable</code>。Signal 的值通过一个 <a href="/api/core/effect"><code>effect</code></a> 进行监控，该 effect 在值更改时将其发出到 Observable。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/core/Component">Component</a>, signal } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> { <a href="/api/core/rxjs-interop/toObservable">toObservable</a> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core/rxjs-interop'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/Component">Component</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> SearchResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  <a href="/api/animations/query">query</a></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/core/Signal">Signal</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(QueryService).query;</span></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  <a href="/api/animations/query">query</a>$</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/core/rxjs-interop/toObservable">toObservable</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.<a href="/api/animations/query">query</a>);</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">  results$</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.<a href="/api/animations/query">query</a>$.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">pipe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    switchMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70"><a href="/api/animations/query">query</a></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.http.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'/search?q='</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> <a href="/api/animations/query">query</a> ))</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  );</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p>随着 <a href="/api/animations/query"><code>query</code></a> Signal 的变化，<code>query$</code> Observable 会发出最新的查询并触发新的 HTTP 请求。</p>

  <h3 id="injection-context-1">
    <a href="#injection-context-1" class="docs-anchor" tabindex="-1" aria-label="Link to Injection context">注入上下文</a>
  </h3>
  <p><a href="/api/core/rxjs-interop/toObservable"><code>toObservable</code></a> 默认需要在<a href="guide/di/dependency-injection-context">注入上下文</a>中运行，例如在组件或服务的构造期间。如果注入上下文不可用，您可以手动指定要使用的<a href="/api/core/Injector"><code>Injector</code></a>。</p>

  <h3 id="timing-of-toobservable">
    <a href="#timing-of-toobservable" class="docs-anchor" tabindex="-1" aria-label="Link to Timing of <code>toObservable</code>"><code>toObservable</code> 的时序</a>
  </h3>
  <p><a href="/api/core/rxjs-interop/toObservable"><code>toObservable</code></a> 使用 effect 在 <code>ReplaySubject</code> 中跟踪 Signal 的值。订阅时，第一个值（如果可用）可能会同步发出，所有后续值将是异步的。</p>
<p>与 Observable 不同，Signal 从不提供同步的更改通知。即使您多次更新 Signal 的值，<a href="/api/core/rxjs-interop/toObservable"><code>toObservable</code></a> 也只会在 Signal 稳定后发出该值。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> obs$</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/core/rxjs-interop/toObservable">toObservable</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(mySignal);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">obs$.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(value));</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">mySignal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">mySignal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">mySignal.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">);</span></span></code></pre>
  </div><p>在这里，只会记录最后一个值 (3)。</p>

  <h2 id="using-rxresource-for-async-data">
    <a href="#using-rxresource-for-async-data" class="docs-anchor" tabindex="-1" aria-label="Link to Using <code>rxResource</code> for async data">使用 <code>rxResource</code> 处理异步数据</a>
  </h2>
  
    <div class="docs-alert docs-alert-important">
    <p><strong>重要提示：</strong> <a href="/api/core/rxjs-interop/rxResource"><code>rxResource</code></a> 处于<a href="reference/releases#experimental">实验阶段</a>。您可以尝试使用它，但在稳定之前可能会发生更改。</p>

    </div>
    <p>Angular 的 <a href="/guide/signals/resource"></a><a href="/api/core/resource"><code>resource</code></a> 函数为您提供了一种将异步数据整合到应用程序基于 Signal 的代码中的方法。在此模式的基础上，<a href="/api/core/rxjs-interop/rxResource"><code>rxResource</code></a> 允许您定义一个资源，该资源的来源是根据 RxJS <code>Observable</code> 定义的。<code>rxResource</code> 不接受 <code>loader</code> 函数，而是接受一个接受 RxJS <code>Observable</code> 的 <code>stream</code> 函数。</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {<a href="/api/core/Component">Component</a>, inject} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {<a href="/api/core/rxjs-interop/rxResource">rxResource</a>} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> '@angular/core/rxjs-interop'</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">;</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/Component">Component</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> UserProfile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  // This component relies on a service that exposes data through an RxJS Observable.</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  private</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70"> userData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> inject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(MyUserDataClient);</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  protected</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70"> userId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/core/input">input</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">&gt;();</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">  private</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70"> userResource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> <a href="/api/core/rxjs-interop/rxResource">rxResource</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">userId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(),</span></span><span class="line"></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // The `stream` property expects a factory function that returns</span></span><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">    // a data stream as an RxJS Observable.</span></span><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">    stream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: ({</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.userData.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">load</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(params.userId),</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  });</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
  </div><p><code>stream</code> 属性接受一个 RxJS <code>Observable</code> 的工厂函数。此工厂函数会接收资源的 <code>params</code> 值并返回一个 <code>Observable</code>。每次 <code>params</code> 计算产生新值时，资源都会调用此工厂函数。有关传递给工厂函数的参数的更多详细信息，请参阅<a href="/guide/signals/resource#resource-loaders">资源加载器</a>。</p>
<p>在其他所有方面，<a href="/api/core/rxjs-interop/rxResource"><code>rxResource</code></a> 的行为与 <a href="/api/core/resource"><code>resource</code></a> 相同，并提供相同的 API 来指定参数、读取值、检查加载状态和检查错误。</p>
