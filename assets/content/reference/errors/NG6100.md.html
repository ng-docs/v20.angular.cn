<header class="docs-header">
      <docs-breadcrumb></docs-breadcrumb>

      
  <!-- Page title -->
  <div class="docs-page-title">
    <h1 tabindex="-1">NgModule.id 设置为 module.id 反模式</h1>
    <a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/edit/main/adev/src/content/reference/errors/NG6100.md" title="Edit this page" aria-label="Edit this page">
      <!-- Pencil -->
      <docs-icon role="presentation">edit</docs-icon>
    </a>
  </div>
    </header>
    <p>将 <code>module.id</code> 用作 NgModule 的 <code>id</code> 是一种常见的反模式，并且可能在你的代码中没有实际用途。</p>
<p>可以使用 <code>id</code> 声明 NgModule：</p>
<div class="docs-code">
    
    <pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"><a href="/api/core/NgModule">NgModule</a></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">({</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">'my_module'</span></span><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">})</span></span><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> MyModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {}</span></span></code></pre>
  </div><p>声明一个 <code>id</code> 会使该 NgModule 可通过 <a href="/api/core/getNgModuleById"><code>getNgModuleById()</code></a> 操作进行查找。此功能很少使用，主要是在非常特定的捆绑场景中，用于惰性加载 NgModules 而不获取它们的直接引用。在大多数 Angular 代码中，应改用 ES 动态 <code>import()</code> (<code>import('./path/to/module')</code>)，因为它提供了对正在加载的 NgModule 的直接引用，而无需全局注册的副作用。</p>
<p>如果您不使用 <a href="/api/core/getNgModuleById"><code>getNgModuleById</code></a>，则无需为您的 NgModules 提供 <code>id</code>。提供一个 <code>id</code> 有一个显著的缺点：它会使 NgModule 无法进行摇树优化，这会影响您的捆绑包大小。</p>
<p>特别是，指定 <code>id: module.id</code> 的模式源于对 <a href="/api/core/NgModule#id"><code>@NgModule.id</code></a> 的误解。在早期版本的 Angular 中，有时需要在 <a href="/api/core/Component"><code>@Component</code></a> 元数据中包含 <code>moduleId: module.id</code> 属性。</p>
<p>将 <code>module.id</code> 用于 <a href="/api/core/NgModule#id"><code>@NgModule.id</code></a> 可能是由于混淆了 <a href="/api/core/Component#moduleId"><code>@Component.moduleId</code></a> 和 <a href="/api/core/NgModule#id"><code>@NgModule.id</code></a>。<code>module.id</code> 对于 <a href="/api/core/getNgModuleById"><code>getNgModuleById()</code></a> 操作通常没有用，因为 <code>id</code> 需要是一个众所周知的字符串，而 <code>module.id</code> 对消费者来说通常是不透明的。</p>

  <h2 id="debugging-the-error">
    <a href="#debugging-the-error" class="docs-anchor" tabindex="-1" aria-label="Link to Debugging the error">调试错误</a>
  </h2>
  <p>你可以从你的 NgModules 中删除 <code>id: module.id</code> 声明。编译器会忽略此声明，并改为发出此警告。</p>
