<div class="docs-api"><header class="docs-reference-header"><span class="docs-reference-category">@angular/core</span><div class="docs-reference-title"><div><h1>ng-container</h1><div class="docs-api-item-label type-element full">element</div></div><a class="docs-github-links" target="_blank" href="https://github.com/angular/angular/blob/main/tools/manual_api_docs/elements/ng-container.md#L0-L0" title="View source" aria-label="View source"><i role="presentation" aria-hidden="true" class="material-symbols-outlined">code</i></a></div><section class="docs-reference-description"><p>A special element that can hold structural directives without adding new elements to the DOM.</p></section></header><div class="docs-reference-section"><h2 id="description" class="docs-reference-section-heading"><a href="#description" aria-label="Link to Description section" tabindex="-1">Description</a></h2><div><p>A special element that can hold structural directives without adding new elements to the DOM.</p>
<p>The <code>&lt;ng-container&gt;</code> allows us to use structural directives without any extra element, making sure
that the only DOM changes being applied are those dictated by the directives themselves.</p>
<p>This not only increases performance (even so slightly) since the browser ends up rendering less
elements but can also be a valuable asset in having cleaner DOMs and styles alike.</p>
<p>It can for example enable us to use structural directives without breaking styling dependent on a
precise DOM structure (as for example the ones we get when using flex containers, margins, the
child combinator selector, etc.).</p>

  <h2 id="usage-notes">
    <a href="#usage-notes" class="docs-anchor" tabindex="-1" aria-label="Link to Usage notes">Usage notes</a>
  </h2>
  
  <h3 id="with-ngifs">
    <a href="#with-ngifs" class="docs-anchor" tabindex="-1" aria-label="Link to With <code>*NgIf</code>s">With <code>*NgIf</code>s</a>
  </h3>
  <p>One common use case of <code>&lt;ng-container&gt;</code> is alongside the <code>*ngIf</code> structural directive. By using the
special element we can produce very clean templates easy to understand and work with.</p>
<p>For example, we may want to have a number of elements shown conditionally but they do not need to be
all under the same root element. That can be easily done by wrapping them in such a block:</p>
<code-example format="html" language="html">

<p>&lt;ng-container *ngIf="condition"&gt;
  &hellip;
&lt;/ng-container&gt;</p>
</code-example>

<p>This can also be augmented with an <code>else</code> statement alongside an <code>&lt;ng-template&gt;</code> as:</p>
<code-example format="html" language="html">

<p>&lt;ng-container *ngIf="condition; else templateA"&gt;
  &hellip;
&lt;/ng-container&gt;
&lt;ng-template #templateA&gt;
  &hellip;
&lt;/ng-template&gt;</p>
</code-example>


  <h3 id="combination-of-multiple-structural-directives">
    <a href="#combination-of-multiple-structural-directives" class="docs-anchor" tabindex="-1" aria-label="Link to Combination of multiple structural directives">Combination of multiple structural directives</a>
  </h3>
  <p>Multiple structural directives cannot be used on the same element; if you need to take advantage of
more than one structural directive, it is advised to use an <code>&lt;ng-container&gt;</code> per structural
directive.</p>
<p>The most common scenario is with <code>*ngIf</code> and <code>*ngFor</code>. For example, let's imagine that we have a
list of items but each item needs to be displayed only if a certain condition is true. We could be
tempted to try something like:</p>
<code-example format="html" language="html">

<p>&lt;ul&gt;
  &lt;li *ngFor="let item of items" *ngIf="item.isValid"&gt;
    {{ item.name }}
  &lt;/li&gt;
&lt;/ul&gt;</p>
</code-example>

<p>As we said that would not work, what we can do is to simply move one of the structural directives to
an <code>&lt;ng-container&gt;</code> element, which would then wrap the other one, like so:</p>
<code-example format="html" language="html">

<p>&lt;ul&gt;
  &lt;ng-container *ngFor="let item of items"&gt;
    &lt;li *ngIf="item.isValid"&gt;
      {{ item.name }}
    &lt;/li&gt;
  &lt;/ng-container&gt;
&lt;/ul&gt;</p>
</code-example>

<p>This would work as intended without introducing any new unnecessary elements in the DOM.</p>
<p>For more information see <a href="guide/directives/structural-directives#one-structural-directive-per-element">one structural directive per element</a>.</p>

  <h3 id="use-alongside-ngtemplateoutlet">
    <a href="#use-alongside-ngtemplateoutlet" class="docs-anchor" tabindex="-1" aria-label="Link to Use alongside ngTemplateOutlet">Use alongside ngTemplateOutlet</a>
  </h3>
  <p>The <code>NgTemplateOutlet</code> directive can be applied to any element but most of the time it's applied
to <code>&lt;ng-container&gt;</code> ones. By combining the two, we get a very clear and easy to follow HTML and DOM
structure in which no extra elements are necessary and template views are instantiated where
requested.</p>
<p>For example, imagine a situation in which we have a large HTML, in which a small portion needs to be
repeated in different places. A simple solution is to define an <code>&lt;ng-template&gt;</code> containing our
repeating HTML and render that where necessary by using <code>&lt;ng-container&gt;</code> alongside
an <code>NgTemplateOutlet</code>.</p>
<p>Like so:</p>
<code-example format="html" language="html">

<p>&lt;!-- &hellip; --&gt;</p>
<p>&lt;ng-container *ngTemplateOutlet="tmpl; context: {&dollar;implicit: 'Hello'}"&gt;
&lt;/ng-container&gt;</p>
<p>&lt;!-- &hellip; --&gt;</p>
<p>&lt;ng-container *ngTemplateOutlet="tmpl; context: {&dollar;implicit: 'World'}"&gt;
&lt;/ng-container&gt;</p>
<p>&lt;!-- &hellip; --&gt;</p>
<p>&lt;ng-template #tmpl let-text&gt;
  &lt;h1&gt;{{ text }}&lt;/h1&gt;
&lt;/ng-template&gt;</p>
</code-example>

<p>For more information regarding <code>NgTemplateOutlet</code>, see
the <a href="api/common/NgTemplateOutlet"><code>NgTemplateOutlet</code>s api documentation page</a>.</p></div></div></div>